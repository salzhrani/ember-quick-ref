export default {"RSVP":{"name":"RSVP","shortname":"RSVP","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember"},"RSVP.EventTarget":{"name":"RSVP.EventTarget","shortname":"RSVP.EventTarget","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","file":"bower_components/rsvp/lib/rsvp/events.js","line":19},"RSVP.Promise":{"name":"RSVP.Promise","shortname":"RSVP.Promise","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","file":"bower_components/rsvp/lib/rsvp/promise.js","line":34,"description":"Promise objects represent the eventual result of an asynchronous operation. The\nprimary way of interacting with a promise is through its `then` method, which\nregisters callbacks to receive either a promiseâ€™s eventual value or the reason\nwhy the promise cannot be fulfilled.\n\nTerminology\n-----------\n\n- `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n- `thenable` is an object or function that defines a `then` method.\n- `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n- `exception` is a value that is thrown using the throw statement.\n- `reason` is a value that indicates why a promise was rejected.\n- `settled` the final resting state of a promise, fulfilled or rejected.\n\nA promise can be in one of three states: pending, fulfilled, or rejected.\n\nPromises that are fulfilled have a fulfillment value and are in the fulfilled\nstate.  Promises that are rejected have a rejection reason and are in the\nrejected state.  A fulfillment value is never a thenable.\n\nPromises can also be said to *resolve* a value.  If this value is also a\npromise, then the original promise's settled state will match the value's\nsettled state.  So a promise that *resolves* a promise that rejects will\nitself reject, and a promise that *resolves* a promise that fulfills will\nitself fulfill.\n\n\nBasic Usage:\n------------\n\n```js\nvar promise = new Promise(function(resolve, reject) {\n  // on success\n  resolve(value);\n\n  // on failure\n  reject(reason);\n});\n\npromise.then(function(value) {\n  // on fulfillment\n}, function(reason) {\n  // on rejection\n});\n```\n\nAdvanced Usage:\n---------------\n\nPromises shine when abstracting away asynchronous interactions such as\n`XMLHttpRequest`s.\n\n```js\nfunction getJSON(url) {\n  return new Promise(function(resolve, reject){\n    var xhr = new XMLHttpRequest();\n\n    xhr.open('GET', url);\n    xhr.onreadystatechange = handler;\n    xhr.responseType = 'json';\n    xhr.setRequestHeader('Accept', 'application/json');\n    xhr.send();\n\n    function handler() {\n      if (this.readyState === this.DONE) {\n        if (this.status === 200) {\n          resolve(this.response);\n        } else {\n          reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n        }\n      }\n    };\n  });\n}\n\ngetJSON('/posts.json').then(function(json) {\n  // on fulfillment\n}, function(reason) {\n  // on rejection\n});\n```\n\nUnlike callbacks, promises are great composable primitives.\n\n```js\nPromise.all([\n  getJSON('/posts'),\n  getJSON('/comments')\n]).then(function(values){\n  values[0] // => postsJSON\n  values[1] // => commentsJSON\n\n  return values;\n});\n```","params":[{"name":"resolver","description":"","type":"Function"},{"name":"label","description":"optional string for labeling the promise.\nUseful for tooling.","type":"String"}],"is_constructor":1},"Ember.ControllerMixin":{"name":"Ember.ControllerMixin","shortname":"Ember.ControllerMixin","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":["Ember.ArrayController","Ember.Controller","Ember.ObjectController"],"module":"ember","submodule":"ember-application","namespace":"Ember","file":"packages/ember-runtime/lib/mixins/controller.js","line":6,"description":"`Ember.ControllerMixin` provides a standard interface for all classes that\ncompose Ember's controller layer: `Ember.Controller`,\n`Ember.ArrayController`, and `Ember.ObjectController`.","uses":["Ember.ActionHandler"]},"Ember.Application":{"name":"Ember.Application","shortname":"Ember.Application","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-application","namespace":"Ember","file":"packages/ember-application/lib/system/application.js","line":56,"description":"An instance of `Ember.Application` is the starting point for every Ember\napplication. It helps to instantiate, initialize and coordinate the many\nobjects that make up your app.\n\nEach Ember app has one and only one `Ember.Application` object. In fact, the\nvery first thing you should do in your application is create the instance:\n\n```javascript\nwindow.App = Ember.Application.create();\n```\n\nTypically, the application object is the only global variable. All other\nclasses in your app should be properties on the `Ember.Application` instance,\nwhich highlights its first role: a global namespace.\n\nFor example, if you define a view class, it might look like this:\n\n```javascript\nApp.MyView = Ember.View.extend();\n```\n\nBy default, calling `Ember.Application.create()` will automatically initialize\nyour application by calling the `Ember.Application.initialize()` method. If\nyou need to delay initialization, you can call your app's `deferReadiness()`\nmethod. When you are ready for your app to be initialized, call its\n`advanceReadiness()` method.\n\nYou can define a `ready` method on the `Ember.Application` instance, which\nwill be run by Ember when the application is initialized.\n\nBecause `Ember.Application` inherits from `Ember.Namespace`, any classes\nyou create will have useful string representations when calling `toString()`.\nSee the `Ember.Namespace` documentation for more information.\n\nWhile you can think of your `Ember.Application` as a container that holds the\nother classes in your application, there are several other responsibilities\ngoing on under-the-hood that you may want to understand.\n\n### Event Delegation\n\nEmber uses a technique called _event delegation_. This allows the framework\nto set up a global, shared event listener instead of requiring each view to\ndo it manually. For example, instead of each view registering its own\n`mousedown` listener on its associated element, Ember sets up a `mousedown`\nlistener on the `body`.\n\nIf a `mousedown` event occurs, Ember will look at the target of the event and\nstart walking up the DOM node tree, finding corresponding views and invoking\ntheir `mouseDown` method as it goes.\n\n`Ember.Application` has a number of default events that it listens for, as\nwell as a mapping from lowercase events to camel-cased view method names. For\nexample, the `keypress` event causes the `keyPress` method on the view to be\ncalled, the `dblclick` event causes `doubleClick` to be called, and so on.\n\nIf there is a bubbling browser event that Ember does not listen for by\ndefault, you can specify custom events and their corresponding view method\nnames by setting the application's `customEvents` property:\n\n```javascript\nvar App = Ember.Application.create({\n  customEvents: {\n    // add support for the paste event\n    paste: 'paste'\n  }\n});\n```\n\nBy default, the application sets up these event listeners on the document\nbody. However, in cases where you are embedding an Ember application inside\nan existing page, you may want it to set up the listeners on an element\ninside the body.\n\nFor example, if only events inside a DOM element with the ID of `ember-app`\nshould be delegated, set your application's `rootElement` property:\n\n```javascript\nvar App = Ember.Application.create({\n  rootElement: '#ember-app'\n});\n```\n\nThe `rootElement` can be either a DOM element or a jQuery-compatible selector\nstring. Note that *views appended to the DOM outside the root element will\nnot receive events.* If you specify a custom root element, make sure you only\nappend views inside it!\n\nTo learn more about the advantages of event delegation and the Ember view\nlayer, and a list of the event listeners that are setup by default, visit the\n[Ember View Layer guide](http://emberjs.com/guides/understanding-ember/the-view-layer/#toc_event-delegation).\n\n### Initializers\n\nLibraries on top of Ember can add initializers, like so:\n\n```javascript\nEmber.Application.initializer({\n  name: 'api-adapter',\n\n  initialize: function(container, application) {\n    application.register('api-adapter:main', ApiAdapter);\n  }\n});\n```\n\nInitializers provide an opportunity to access the container, which\norganizes the different components of an Ember application. Additionally\nthey provide a chance to access the instantiated application. Beyond\nbeing used for libraries, initializers are also a great way to organize\ndependency injection or setup in your own application.\n\n### Routing\n\nIn addition to creating your application's router, `Ember.Application` is\nalso responsible for telling the router when to start routing. Transitions\nbetween routes can be logged with the `LOG_TRANSITIONS` flag, and more\ndetailed intra-transition logging can be logged with\nthe `LOG_TRANSITIONS_INTERNAL` flag:\n\n```javascript\nvar App = Ember.Application.create({\n  LOG_TRANSITIONS: true, // basic logging of successful transitions\n  LOG_TRANSITIONS_INTERNAL: true // detailed logging of all routing steps\n});\n```\n\nBy default, the router will begin trying to translate the current URL into\napplication state once the browser emits the `DOMContentReady` event. If you\nneed to defer routing, you can call the application's `deferReadiness()`\nmethod. Once routing can begin, call the `advanceReadiness()` method.\n\nIf there is any setup required before routing begins, you can implement a\n`ready()` method on your app that will be invoked immediately before routing\nbegins.\n```","extends":"Ember.Namespace"},"Ember.DefaultResolver":{"name":"Ember.DefaultResolver","shortname":"Ember.DefaultResolver","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-application","namespace":"Ember","file":"packages/ember-application/lib/system/resolver.js","line":35,"description":"The DefaultResolver defines the default lookup rules to resolve\ncontainer lookups before consulting the container for registered\nitems:\n\n* templates are looked up on `Ember.TEMPLATES`\n* other names are looked up on the application after converting\n  the name. For example, `controller:post` looks up\n  `App.PostController` by default.\n* there are some nuances (see examples below)\n\n### How Resolving Works\n\nThe container calls this object's `resolve` method with the\n`fullName` argument.\n\nIt first parses the fullName into an object using `parseName`.\n\nThen it checks for the presence of a type-specific instance\nmethod of the form `resolve[Type]` and calls it if it exists.\nFor example if it was resolving 'template:post', it would call\nthe `resolveTemplate` method.\n\nIts last resort is to call the `resolveOther` method.\n\nThe methods of this object are designed to be easy to override\nin a subclass. For example, you could enhance how a template\nis resolved like so:\n\n```javascript\nApp = Ember.Application.create({\n  Resolver: Ember.DefaultResolver.extend({\n    resolveTemplate: function(parsedName) {\n      var resolvedTemplate = this._super(parsedName);\n      if (resolvedTemplate) { return resolvedTemplate; }\n      return Ember.TEMPLATES['not_found'];\n    }\n  })\n});\n```\n\nSome examples of how names are resolved:\n\n```\n'template:post'           //=> Ember.TEMPLATES['post']\n'template:posts/byline'   //=> Ember.TEMPLATES['posts/byline']\n'template:posts.byline'   //=> Ember.TEMPLATES['posts/byline']\n'template:blogPost'       //=> Ember.TEMPLATES['blogPost']\n                          //   OR\n                          //   Ember.TEMPLATES['blog_post']\n'controller:post'         //=> App.PostController\n'controller:posts.index'  //=> App.PostsIndexController\n'controller:blog/post'    //=> Blog.PostController\n'controller:basic'        //=> Ember.Controller\n'route:post'              //=> App.PostRoute\n'route:posts.index'       //=> App.PostsIndexRoute\n'route:blog/post'         //=> Blog.PostRoute\n'route:basic'             //=> Ember.Route\n'view:post'               //=> App.PostView\n'view:posts.index'        //=> App.PostsIndexView\n'view:blog/post'          //=> Blog.PostView\n'view:basic'              //=> Ember.View\n'foo:post'                //=> App.PostFoo\n'model:post'              //=> App.Post\n```","extends":"Ember.Object"},"Ember":{"name":"Ember","shortname":"Ember","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-metal","namespace":"","file":"packages/ember-metal/lib/core.js","line":8,"description":"All Ember methods and functions are defined inside of this namespace. You\ngenerally should not add new properties to this namespace as it may be\noverwritten by future versions of Ember.\n\nYou can also use the shorthand `Em` instead of `Ember`.\n\nEmber-Runtime is a framework that provides core functions for Ember including\ncross-platform functions, support for property observing and objects. Its\nfocus is on small size and performance. You can use this in place of or\nalong-side other cross-platform libraries such as jQuery.\n\nThe core Runtime framework is based on the jQuery API with a number of\nperformance optimizations.","static":1,"version":"VERSION_STRING_PLACEHOLDER"},"Ember.ContainerDebugAdapter":{"name":"Ember.ContainerDebugAdapter","shortname":"Ember.ContainerDebugAdapter","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-extension-support","namespace":"Ember","file":"packages/ember-extension-support/lib/container_debug_adapter.js","line":16,"description":"The `ContainerDebugAdapter` helps the container and resolver interface\nwith tools that debug Ember such as the\n[Ember Extension](https://github.com/tildeio/ember-extension)\nfor Chrome and Firefox.\n\nThis class can be extended by a custom resolver implementer\nto override some of the methods with library-specific code.\n\nThe methods likely to be overridden are:\n\n* `canCatalogEntriesByType`\n* `catalogEntriesByType`\n\nThe adapter will need to be registered\nin the application's container as `container-debug-adapter:main`\n\nExample:\n\n```javascript\nApplication.initializer({\n  name: \"containerDebugAdapter\",\n\n  initialize: function(container, application) {\n    application.register('container-debug-adapter:main', require('app/container-debug-adapter'));\n  }\n});\n```","extends":"EmberObject","since":"1.5.0"},"Ember.DataAdapter":{"name":"Ember.DataAdapter","shortname":"Ember.DataAdapter","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-extension-support","namespace":"Ember","file":"packages/ember-extension-support/lib/data_adapter.js","line":15,"description":"The `DataAdapter` helps a data persistence library\ninterface with tools that debug Ember such\nas the [Ember Extension](https://github.com/tildeio/ember-extension)\nfor Chrome and Firefox.\n\nThis class will be extended by a persistence library\nwhich will override some of the methods with\nlibrary-specific code.\n\nThe methods likely to be overridden are:\n\n* `getFilters`\n* `detect`\n* `columnsForType`\n* `getRecords`\n* `getRecordColumnValues`\n* `getRecordKeywords`\n* `getRecordFilterValues`\n* `getRecordColor`\n* `observeRecord`\n\nThe adapter will need to be registered\nin the application's container as `dataAdapter:main`\n\nExample:\n\n```javascript\nApplication.initializer({\n  name: \"data-adapter\",\n\n  initialize: function(container, application) {\n    application.register('data-adapter:main', DS.DataAdapter);\n  }\n});\n```","extends":"EmberObject"},"Ember.Handlebars":{"name":"Ember.Handlebars","shortname":"Ember.Handlebars","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-handlebars-compiler","namespace":"Ember","file":"packages/ember-handlebars-compiler/lib/main.js","line":43,"description":"Prepares the Handlebars templating library for use inside Ember's view\nsystem.\n\nThe `Ember.Handlebars` object is the standard Handlebars library, extended to\nuse Ember's `get()` method instead of direct property access, which allows\ncomputed properties to be used inside templates.\n\nTo create an `Ember.Handlebars` template, call `Ember.Handlebars.compile()`.\nThis will return a function that can be used by `Ember.View` for rendering."},"Ember.Handlebars.helpers":{"name":"Ember.Handlebars.helpers","shortname":"Ember.Handlebars.helpers","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-handlebars-compiler","namespace":"Ember.Handlebars","file":"packages/ember-handlebars-compiler/lib/main.js","line":146},"Ember.Handlebars.Compiler":{"name":"Ember.Handlebars.Compiler","shortname":"Ember.Handlebars.Compiler","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-handlebars-compiler","namespace":"Ember.Handlebars","file":"packages/ember-handlebars-compiler/lib/main.js","line":152,"description":"Override the the opcode compiler and JavaScript compiler for Handlebars.","access":"private","tagname":"","is_constructor":1},"Ember.Handlebars.JavaScriptCompiler":{"name":"Ember.Handlebars.JavaScriptCompiler","shortname":"Ember.Handlebars.JavaScriptCompiler","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-handlebars-compiler","namespace":"Ember.Handlebars","file":"packages/ember-handlebars-compiler/lib/main.js","line":169,"access":"private","tagname":"","is_constructor":1},"Ember.Checkbox":{"name":"Ember.Checkbox","shortname":"Ember.Checkbox","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-handlebars","namespace":"Ember","file":"packages/ember-handlebars/lib/controls/checkbox.js","line":10,"description":"The internal class used to create text inputs when the `{{input}}`\nhelper is used with `type` of `checkbox`.\n\nSee [handlebars.helpers.input](/api/classes/Ember.Handlebars.helpers.html#method_input)  for usage details.\n\n## Direct manipulation of `checked`\n\nThe `checked` attribute of an `Ember.Checkbox` object should always be set\nthrough the Ember object or by interacting with its rendered element\nrepresentation via the mouse, keyboard, or touch. Updating the value of the\ncheckbox via jQuery will result in the checked value of the object and its\nelement losing synchronization.\n\n## Layout and LayoutName properties\n\nBecause HTML `input` elements are self closing `layout` and `layoutName`\nproperties will not be applied. See [Ember.View](/api/classes/Ember.View.html)'s\nlayout section for more information.","extends":"Ember.View"},"Ember.Select":{"name":"Ember.Select","shortname":"Ember.Select","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-handlebars","namespace":"Ember","file":"packages/ember-handlebars/lib/controls/select.js","line":93,"description":"The `Ember.Select` view class renders a\n[select](https://developer.mozilla.org/en/HTML/Element/select) HTML element,\nallowing the user to choose from a list of options.\n\nThe text and `value` property of each `<option>` element within the\n`<select>` element are populated from the objects in the `Element.Select`'s\n`content` property. The underlying data object of the selected `<option>` is\nstored in the `Element.Select`'s `value` property.\n\n## The Content Property (array of strings)\n\nThe simplest version of an `Ember.Select` takes an array of strings as its\n`content` property. The string will be used as both the `value` property and\nthe inner text of each `<option>` element inside the rendered `<select>`.\n\nExample:\n\n```javascript\nApp.ApplicationController = Ember.ObjectController.extend({\n  names: [\"Yehuda\", \"Tom\"]\n});\n```\n\n```handlebars\n{{view \"select\" content=names}}\n```\n\nWould result in the following HTML:\n\n```html\n<select class=\"ember-select\">\n  <option value=\"Yehuda\">Yehuda</option>\n  <option value=\"Tom\">Tom</option>\n</select>\n```\n\nYou can control which `<option>` is selected through the `Ember.Select`'s\n`value` property:\n\n```javascript\nApp.ApplicationController = Ember.ObjectController.extend({\n  selectedName: 'Tom',\n  names: [\"Yehuda\", \"Tom\"]\n});\n```\n\n```handlebars\n{{view \"select\" content=names value=selectedName}}\n```\n\nWould result in the following HTML with the `<option>` for 'Tom' selected:\n\n```html\n<select class=\"ember-select\">\n  <option value=\"Yehuda\">Yehuda</option>\n  <option value=\"Tom\" selected=\"selected\">Tom</option>\n</select>\n```\n\nA user interacting with the rendered `<select>` to choose \"Yehuda\" would\nupdate the value of `selectedName` to \"Yehuda\".\n\n## The Content Property (array of Objects)\n\nAn `Ember.Select` can also take an array of JavaScript or Ember objects as\nits `content` property.\n\nWhen using objects you need to tell the `Ember.Select` which property should\nbe accessed on each object to supply the `value` attribute of the `<option>`\nand which property should be used to supply the element text.\n\nThe `optionValuePath` option is used to specify the path on each object to\nthe desired property for the `value` attribute. The `optionLabelPath`\nspecifies the path on each object to the desired property for the\nelement's text. Both paths must reference each object itself as `content`:\n\n```javascript\nApp.ApplicationController = Ember.ObjectController.extend({\n  programmers: [\n    {firstName: \"Yehuda\", id: 1},\n    {firstName: \"Tom\",    id: 2}\n  ]\n});\n```\n\n```handlebars\n{{view \"select\"\n       content=programmers\n       optionValuePath=\"content.id\"\n       optionLabelPath=\"content.firstName\"}}\n```\n\nWould result in the following HTML:\n\n```html\n<select class=\"ember-select\">\n  <option value=\"1\">Yehuda</option>\n  <option value=\"2\">Tom</option>\n</select>\n```\n\nThe `value` attribute of the selected `<option>` within an `Ember.Select`\ncan be bound to a property on another object:\n\n```javascript\nApp.ApplicationController = Ember.ObjectController.extend({\n  programmers: [\n    {firstName: \"Yehuda\", id: 1},\n    {firstName: \"Tom\",    id: 2}\n  ],\n  currentProgrammer: {\n    id: 2\n  }\n});\n```\n\n```handlebars\n{{view \"select\"\n       content=programmers\n       optionValuePath=\"content.id\"\n       optionLabelPath=\"content.firstName\"\n       value=currentProgrammer.id}}\n```\n\nWould result in the following HTML with a selected option:\n\n```html\n<select class=\"ember-select\">\n  <option value=\"1\">Yehuda</option>\n  <option value=\"2\" selected=\"selected\">Tom</option>\n</select>\n```\n\nInteracting with the rendered element by selecting the first option\n('Yehuda') will update the `id` of `currentProgrammer`\nto match the `value` property of the newly selected `<option>`.\n\nAlternatively, you can control selection through the underlying objects\nused to render each object by binding the `selection` option. When the selected\n`<option>` is changed, the property path provided to `selection`\nwill be updated to match the content object of the rendered `<option>`\nelement:\n\n```javascript\n\nvar yehuda = {firstName: \"Yehuda\", id: 1, bff4eva: 'tom'}\nvar tom = {firstName: \"Tom\", id: 2, bff4eva: 'yehuda'};\n\nApp.ApplicationController = Ember.ObjectController.extend({\n  selectedPerson: tom,\n  programmers: [ yehuda, tom ]\n});\n```\n\n```handlebars\n{{view \"select\"\n       content=programmers\n       optionValuePath=\"content.id\"\n       optionLabelPath=\"content.firstName\"\n       selection=selectedPerson}}\n```\n\nWould result in the following HTML with a selected option:\n\n```html\n<select class=\"ember-select\">\n  <option value=\"1\">Yehuda</option>\n  <option value=\"2\" selected=\"selected\">Tom</option>\n</select>\n```\n\nInteracting with the rendered element by selecting the first option\n('Yehuda') will update the `selectedPerson` to match the object of\nthe newly selected `<option>`. In this case it is the first object\nin the `programmers`\n\n## Supplying a Prompt\n\nA `null` value for the `Ember.Select`'s `value` or `selection` property\nresults in there being no `<option>` with a `selected` attribute:\n\n```javascript\nApp.ApplicationController = Ember.ObjectController.extend({\n  selectedProgrammer: null,\n  programmers: [\"Yehuda\", \"Tom\"]\n});\n```\n\n``` handlebars\n{{view \"select\"\n       content=programmers\n       value=selectedProgrammer\n}}\n```\n\nWould result in the following HTML:\n\n```html\n<select class=\"ember-select\">\n  <option value=\"Yehuda\">Yehuda</option>\n  <option value=\"Tom\">Tom</option>\n</select>\n```\n\nAlthough `selectedProgrammer` is `null` and no `<option>`\nhas a `selected` attribute the rendered HTML will display the\nfirst item as though it were selected. You can supply a string\nvalue for the `Ember.Select` to display when there is no selection\nwith the `prompt` option:\n\n```javascript\nApp.ApplicationController = Ember.ObjectController.extend({\n  selectedProgrammer: null,\n  programmers: [ \"Yehuda\", \"Tom\" ]\n});\n```\n\n```handlebars\n{{view \"select\"\n       content=programmers\n       value=selectedProgrammer\n       prompt=\"Please select a name\"\n}}\n```\n\nWould result in the following HTML:\n\n```html\n<select class=\"ember-select\">\n  <option>Please select a name</option>\n  <option value=\"Yehuda\">Yehuda</option>\n  <option value=\"Tom\">Tom</option>\n</select>\n```","extends":"Ember.View"},"Ember.TextArea":{"name":"Ember.TextArea","shortname":"Ember.TextArea","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-handlebars","namespace":"Ember","file":"packages/ember-handlebars/lib/controls/text_area.js","line":11,"description":"The internal class used to create textarea element when the `{{textarea}}`\nhelper is used.\n\nSee [handlebars.helpers.textarea](/api/classes/Ember.Handlebars.helpers.html#method_textarea)  for usage details.\n\n## Layout and LayoutName properties\n\nBecause HTML `textarea` elements do not contain inner HTML the `layout` and\n`layoutName` properties will not be applied. See [Ember.View](/api/classes/Ember.View.html)'s\nlayout section for more information.","extends":"Ember.Component","uses":["Ember.TextSupport"]},"Ember.TextField":{"name":"Ember.TextField","shortname":"Ember.TextField","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-handlebars","namespace":"Ember","file":"packages/ember-handlebars/lib/controls/text_field.js","line":8,"description":"The internal class used to create text inputs when the `{{input}}`\n  helper is used with `type` of `text`.\nSee [Handlebars.helpers.input](/api/classes/Ember.Handlebars.helpers.html#method_input)  for usage details.\n## Layout and LayoutName properties\nBecause HTML `input` elements are self closing `layout` and `layoutName`\n  properties will not be applied. See [Ember.View](/api/classes/Ember.View.html)'s\n  layout section for more information.","extends":"Ember.Component","uses":["Ember.TextSupport"]},"Ember.TextSupport":{"name":"Ember.TextSupport","shortname":"Ember.TextSupport","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":["Ember.TextArea","Ember.TextField"],"module":"ember","submodule":"ember-handlebars","namespace":"Ember","file":"packages/ember-handlebars/lib/controls/text_support.js","line":11,"description":"Shared mixin used by `Ember.TextField` and `Ember.TextArea`.","uses":["Ember.TargetActionSupport"],"extends":"Ember.Mixin","access":"private","tagname":""},"Ember._HandlebarsBoundView":{"name":"Ember._HandlebarsBoundView","shortname":"Ember._HandlebarsBoundView","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-handlebars","namespace":"Ember","file":"packages/ember-handlebars/lib/views/handlebars_bound_view.js","line":122,"description":"`Ember._HandlebarsBoundView` is a private view created by the Handlebars\n`{{bind}}` helpers that is used to keep track of bound properties.\n\nEvery time a property is bound using a `{{mustache}}`, an anonymous subclass\nof `Ember._HandlebarsBoundView` is created with the appropriate sub-template\nand context set up. When the associated property changes, just the template\nfor this view will re-render.","extends":"Ember._MetamorphView","access":"private","tagname":""},"Ember._Metamorph":{"name":"Ember._Metamorph","shortname":"Ember._Metamorph","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":["Ember._MetamorphView","Ember._SimpleMetamorphView"],"module":"ember","submodule":"ember-handlebars","namespace":"Ember","file":"packages/ember-handlebars/lib/views/metamorph_view.js","line":16,"access":"private","tagname":""},"Ember._MetamorphView":{"name":"Ember._MetamorphView","shortname":"Ember._MetamorphView","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-handlebars","namespace":"Ember","file":"packages/ember-handlebars/lib/views/metamorph_view.js","line":34,"extends":"Ember.View","uses":["Ember._Metamorph"],"access":"private","tagname":""},"Ember._SimpleMetamorphView":{"name":"Ember._SimpleMetamorphView","shortname":"Ember._SimpleMetamorphView","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-handlebars","namespace":"Ember","file":"packages/ember-handlebars/lib/views/metamorph_view.js","line":43,"extends":"Ember.CoreView","uses":["Ember._Metamorph"],"access":"private","tagname":""},"Ember.String":{"name":"Ember.String","shortname":"Ember.String","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","namespace":"Ember","file":"packages/ember-runtime/lib/system/string.js","line":125,"description":"Defines string helper methods including string formatting and localization.\nUnless `Ember.EXTEND_PROTOTYPES.String` is `false` these methods will also be\nadded to the `String.prototype` as well.","submodule":"ember-runtime","static":1},"String":{"name":"String","shortname":"String","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","namespace":""},"Ember.platform":{"name":"Ember.platform","shortname":"Ember.platform","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember-metal","namespace":"Ember","file":"packages/ember-metal/lib/platform.js","line":15,"static":1,"description":"Platform specific methods and feature detectors needed by the framework."},"Ember.Binding":{"name":"Ember.Binding","shortname":"Ember.Binding","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember-metal","namespace":"Ember","file":"packages/ember-metal/lib/binding.js","line":330,"description":"An `Ember.Binding` connects the properties of two objects so that whenever\nthe value of one property changes, the other property will be changed also.\n\n## Automatic Creation of Bindings with `/^*Binding/`-named Properties\n\nYou do not usually create Binding objects directly but instead describe\nbindings in your class or object definition using automatic binding\ndetection.\n\nProperties ending in a `Binding` suffix will be converted to `Ember.Binding`\ninstances. The value of this property should be a string representing a path\nto another object or a custom binding instance created using Binding helpers\n(see \"One Way Bindings\"):\n\n```\nvalueBinding: \"MyApp.someController.title\"\n```\n\nThis will create a binding from `MyApp.someController.title` to the `value`\nproperty of your object instance automatically. Now the two values will be\nkept in sync.\n\n## One Way Bindings\n\nOne especially useful binding customization you can use is the `oneWay()`\nhelper. This helper tells Ember that you are only interested in\nreceiving changes on the object you are binding from. For example, if you\nare binding to a preference and you want to be notified if the preference\nhas changed, but your object will not be changing the preference itself, you\ncould do:\n\n```\nbigTitlesBinding: Ember.Binding.oneWay(\"MyApp.preferencesController.bigTitles\")\n```\n\nThis way if the value of `MyApp.preferencesController.bigTitles` changes the\n`bigTitles` property of your object will change also. However, if you\nchange the value of your `bigTitles` property, it will not update the\n`preferencesController`.\n\nOne way bindings are almost twice as fast to setup and twice as fast to\nexecute because the binding only has to worry about changes to one side.\n\nYou should consider using one way bindings anytime you have an object that\nmay be created frequently and you do not intend to change a property; only\nto monitor it for changes (such as in the example above).\n\n## Adding Bindings Manually\n\nAll of the examples above show you how to configure a custom binding, but the\nresult of these customizations will be a binding template, not a fully active\nBinding instance. The binding will actually become active only when you\ninstantiate the object the binding belongs to. It is useful however, to\nunderstand what actually happens when the binding is activated.\n\nFor a binding to function it must have at least a `from` property and a `to`\nproperty. The `from` property path points to the object/key that you want to\nbind from while the `to` path points to the object/key you want to bind to.\n\nWhen you define a custom binding, you are usually describing the property\nyou want to bind from (such as `MyApp.someController.value` in the examples\nabove). When your object is created, it will automatically assign the value\nyou want to bind `to` based on the name of your binding key. In the\nexamples above, during init, Ember objects will effectively call\nsomething like this on your binding:\n\n```javascript\nbinding = Ember.Binding.from(\"valueBinding\").to(\"value\");\n```\n\nThis creates a new binding instance based on the template you provide, and\nsets the to path to the `value` property of the new object. Now that the\nbinding is fully configured with a `from` and a `to`, it simply needs to be\nconnected to become active. This is done through the `connect()` method:\n\n```javascript\nbinding.connect(this);\n```\n\nNote that when you connect a binding you pass the object you want it to be\nconnected to. This object will be used as the root for both the from and\nto side of the binding when inspecting relative paths. This allows the\nbinding to be automatically inherited by subclassed objects as well.\n\nThis also allows you to bind between objects using the paths you declare in\n`from` and `to`:\n\n```javascript\n// Example 1\nbinding = Ember.Binding.from(\"App.someObject.value\").to(\"value\");\nbinding.connect(this);\n\n// Example 2\nbinding = Ember.Binding.from(\"parentView.value\").to(\"App.someObject.value\");\nbinding.connect(this);\n```\n\nNow that the binding is connected, it will observe both the from and to side\nand relay changes.\n\nIf you ever needed to do so (you almost never will, but it is useful to\nunderstand this anyway), you could manually create an active binding by\nusing the `Ember.bind()` helper method. (This is the same method used by\nto setup your bindings on objects):\n\n```javascript\nEmber.bind(MyApp.anotherObject, \"value\", \"MyApp.someController.value\");\n```\n\nBoth of these code fragments have the same effect as doing the most friendly\nform of binding creation like so:\n\n```javascript\nMyApp.anotherObject = Ember.Object.create({\n  valueBinding: \"MyApp.someController.value\",\n\n  // OTHER CODE FOR THIS OBJECT...\n});\n```\n\nEmber's built in binding creation method makes it easy to automatically\ncreate bindings for you. You should always use the highest-level APIs\navailable, even if you understand how it works underneath.","since":"Ember 0.9"},"Ember.ComputedProperty":{"name":"Ember.ComputedProperty","shortname":"Ember.ComputedProperty","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember-metal","namespace":"Ember","file":"packages/ember-metal/lib/computed.js","line":37,"description":"A computed property transforms an object's function into a property.\n\nBy default the function backing the computed property will only be called\nonce and the result will be cached. You can specify various properties\nthat your computed property depends on. This will force the cached\nresult to be recomputed if the dependencies are modified.\n\nIn the following example we declare a computed property (by calling\n`.property()` on the fullName function) and setup the property\ndependencies (depending on firstName and lastName). The fullName function\nwill be called once (regardless of how many times it is accessed) as long\nas its dependencies have not changed. Once firstName or lastName are updated\nany future calls (or anything bound) to fullName will incorporate the new\nvalues.\n\n```javascript\nvar Person = Ember.Object.extend({\n  // these will be supplied by `create`\n  firstName: null,\n  lastName: null,\n\n  fullName: function() {\n    var firstName = this.get('firstName');\n    var lastName = this.get('lastName');\n\n   return firstName + ' ' + lastName;\n  }.property('firstName', 'lastName')\n});\n\nvar tom = Person.create({\n  firstName: 'Tom',\n  lastName: 'Dale'\n});\n\ntom.get('fullName') // 'Tom Dale'\n```\n\nYou can also define what Ember should do when setting a computed property.\nIf you try to set a computed property, it will be invoked with the key and\nvalue you want to set it to. You can also accept the previous value as the\nthird parameter.\n\n```javascript\nvar Person = Ember.Object.extend({\n  // these will be supplied by `create`\n  firstName: null,\n  lastName: null,\n\n  fullName: function(key, value, oldValue) {\n    // getter\n    if (arguments.length === 1) {\n      var firstName = this.get('firstName');\n      var lastName = this.get('lastName');\n\n      return firstName + ' ' + lastName;\n\n    // setter\n    } else {\n      var name = value.split(' ');\n\n      this.set('firstName', name[0]);\n      this.set('lastName', name[1]);\n\n      return value;\n    }\n  }.property('firstName', 'lastName')\n});\n\nvar person = Person.create();\n\nperson.set('fullName', 'Peter Wagenet');\nperson.get('firstName'); // 'Peter'\nperson.get('lastName');  // 'Wagenet'\n```","extends":"Ember.Descriptor","is_constructor":1},"Ember.FEATURES":{"name":"Ember.FEATURES","shortname":"Ember.FEATURES","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-metal","namespace":"Ember","file":"packages/ember-metal/lib/core.js","line":91,"description":"Hash of enabled Canary features. Add to this before creating your application.\n\nYou can also define `ENV.FEATURES` if you need to enable features flagged at runtime.","static":1,"since":"1.1.0"},"Ember.EnumerableUtils":{"name":"Ember.EnumerableUtils","shortname":"Ember.EnumerableUtils","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember-metal","namespace":"Ember","file":"packages/ember-metal/lib/enumerable_utils.js","line":10,"description":"Defines some convenience methods for working with Enumerables.\n`Ember.EnumerableUtils` uses `Ember.ArrayPolyfills` when necessary.","static":1},"Ember.Error":{"name":"Ember.Error","shortname":"Ember.Error","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember-metal","namespace":"Ember","file":"packages/ember-metal/lib/error.js","line":13,"description":"A subclass of the JavaScript Error object for use in Ember.","extends":"Error","is_constructor":1},"Ember.InjectedProperty":{"name":"Ember.InjectedProperty","shortname":"Ember.InjectedProperty","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember-metal","namespace":"Ember","file":"packages/ember-metal/lib/injected_property.js","line":8,"description":"Read-only property that returns the result of a container lookup.","extends":"Ember.Descriptor","is_constructor":1,"params":[{"name":"type","description":"The container type the property will lookup","type":"String"},{"name":"name","description":"(optional) The name the property will lookup, defaults\n       to the property's name","type":"String"}]},"Ember.Instrumentation":{"name":"Ember.Instrumentation","shortname":"Ember.Instrumentation","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember-metal","namespace":"Ember.Instrumentation","file":"packages/ember-metal/lib/instrumentation.js","line":4,"description":"The purpose of the Ember Instrumentation module is\nto provide efficient, general-purpose instrumentation\nfor Ember.\n\nSubscribe to a listener by using `Ember.subscribe`:\n\n```javascript\nEmber.subscribe(\"render\", {\n  before: function(name, timestamp, payload) {\n\n  },\n\n  after: function(name, timestamp, payload) {\n\n  }\n});\n```\n\nIf you return a value from the `before` callback, that same\nvalue will be passed as a fourth parameter to the `after`\ncallback.\n\nInstrument a block of code by using `Ember.instrument`:\n\n```javascript\nEmber.instrument(\"render.handlebars\", payload, function() {\n  // rendering logic\n}, binding);\n```\n\nEvent names passed to `Ember.instrument` are namespaced\nby periods, from more general to more specific. Subscribers\ncan listen for events by whatever level of granularity they\nare interested in.\n\nIn the above example, the event is `render.handlebars`,\nand the subscriber listened for all events beginning with\n`render`. It would receive callbacks for events named\n`render`, `render.handlebars`, `render.container`, or\neven `render.handlebars.layout`.","static":1},"Ember.Logger":{"name":"Ember.Logger","shortname":"Ember.Logger","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember-metal","namespace":"Ember","file":"packages/ember-metal/lib/logger.js","line":48,"description":"Inside Ember-Metal, simply uses the methods from `imports.console`.\nOverride this to provide more robust logging functionality."},"Ember.OrderedSet":{"name":"Ember.OrderedSet","shortname":"Ember.OrderedSet","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember-metal","namespace":"Ember","file":"packages/ember-metal/lib/map.js","line":58,"description":"This class is used internally by Ember and Ember Data.\nPlease do not use it at this time. We plan to clean it up\nand add many tests soon.","is_constructor":1,"access":"private","tagname":""},"Ember.Map":{"name":"Ember.Map","shortname":"Ember.Map","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember-metal","namespace":"Ember","file":"packages/ember-metal/lib/map.js","line":235,"description":"A Map stores values indexed by keys. Unlike JavaScript's\ndefault Objects, the keys of a Map can be any JavaScript\nobject.\n\nInternally, a Map has two data structures:\n\n1. `keys`: an OrderedSet of all of the existing keys\n2. `values`: a JavaScript Object indexed by the `Ember.guidFor(key)`\n\nWhen a key/value pair is added for the first time, we\nadd the key to the `keys` OrderedSet, and create or\nreplace an entry in `values`. When an entry is deleted,\nwe delete its entry in `keys` and `values`.","access":"private","tagname":"","is_constructor":1},"Ember.MapWithDefault":{"name":"Ember.MapWithDefault","shortname":"Ember.MapWithDefault","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember-metal","namespace":"Ember","file":"packages/ember-metal/lib/map.js","line":437,"extends":"Ember.Map","access":"private","tagname":"","is_constructor":1,"params":[{"name":"options","description":"","optional":true,"props":[{"name":"defaultValue","description":"","type":"*","optional":true}]}]},"Ember.Mixin":{"name":"Ember.Mixin","shortname":"Ember.Mixin","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-metal","namespace":"Ember","file":"packages/ember-metal/lib/mixin.js","line":469,"description":"The `Ember.Mixin` class allows you to create mixins, whose properties can be\nadded to other classes. For instance,\n\n```javascript\nApp.Editable = Ember.Mixin.create({\n  edit: function() {\n    console.log('starting to edit');\n    this.set('isEditing', true);\n  },\n  isEditing: false\n});\n\n// Mix mixins into classes by passing them as the first arguments to\n// .extend.\nApp.CommentView = Ember.View.extend(App.Editable, {\n  template: Ember.Handlebars.compile('{{#if view.isEditing}}...{{else}}...{{/if}}')\n});\n\ncommentView = App.CommentView.create();\ncommentView.edit(); // outputs 'starting to edit'\n```\n\nNote that Mixins are created with `Ember.Mixin.create`, not\n`Ember.Mixin.extend`.\n\nNote that mixins extend a constructor's prototype so arrays and object literals\ndefined as properties will be shared amongst objects that implement the mixin.\nIf you want to define a property in a mixin that is not shared, you can define\nit either as a computed property or have it be created on initialization of the object.\n\n```javascript\n//filters array will be shared amongst any object implementing mixin\nApp.Filterable = Ember.Mixin.create({\n  filters: Ember.A()\n});\n\n//filters will be a separate  array for every object implementing the mixin\nApp.Filterable = Ember.Mixin.create({\n  filters: Ember.computed(function(){return Ember.A();})\n});\n\n//filters will be created as a separate array during the object's initialization\nApp.Filterable = Ember.Mixin.create({\n  init: function() {\n    this._super();\n    this.set(\"filters\", Ember.A());\n  }\n});\n```"},"Ember.Descriptor":{"name":"Ember.Descriptor","shortname":"Ember.Descriptor","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember-metal","namespace":"Ember","file":"packages/ember-metal/lib/properties.js","line":16,"description":"Objects of this type can implement an interface to respond to requests to\nget and set. The default implementation handles simple properties.\n\nYou generally won't need to create or subclass this directly.","access":"private","tagname":"","is_constructor":1},"Ember.run":{"name":"Ember.run","shortname":"Ember.run","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember-metal","namespace":"Ember","file":"packages/ember-metal/lib/run_loop.js","line":40,"description":"Runs the passed target and method inside of a RunLoop, ensuring any\ndeferred actions including bindings and views updates are flushed at the\nend.\n\nNormally you should not need to invoke this method yourself. However if\nyou are implementing raw event handlers when interfacing with other\nlibraries or plugins, you should probably wrap all of your code inside this\ncall.\n\n```javascript\nrun(function() {\n  // code to be execute within a RunLoop\n});\n```","static":1,"is_constructor":1,"params":[{"name":"target","description":"target of method to call","type":"Object","optional":true},{"name":"method","description":"Method to invoke.\n  May be a function or a string. If you pass a string\n  then it will be looked up on the passed target.","type":"Function|String"},{"name":"args*","description":"Any additional arguments you wish to pass to the method.","type":"Object","optional":true}],"return":{"description":"return value from invoking the passed function.","type":"Object"}},"Ember.LinkView":{"name":"Ember.LinkView","shortname":"Ember.LinkView","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-routing","namespace":"Ember","file":"packages/ember-routing-handlebars/lib/helpers/link_to.js","line":42,"description":"`Ember.LinkView` renders an element whose `click` event triggers a\ntransition of the application's instance of `Ember.Router` to\na supplied route by name.\n\nInstances of `LinkView` will most likely be created through\nthe `link-to` Handlebars helper, but properties of this class\ncan be overridden to customize application-wide behavior.","extends":"Ember.View","see":["{Handlebars.helpers.link-to}"]},"Ember.Location":{"name":"Ember.Location","shortname":"Ember.Location","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-routing","namespace":"Ember","file":"packages/ember-routing/lib/location/api.js","line":8,"description":"Ember.Location returns an instance of the correct implementation of\nthe `location` API.\n\n## Implementations\n\nYou can pass an implementation name (`hash`, `history`, `none`) to force a\nparticular implementation to be used in your application.\n\n### HashLocation\n\nUsing `HashLocation` results in URLs with a `#` (hash sign) separating the\nserver side URL portion of the URL from the portion that is used by Ember.\nThis relies upon the `hashchange` event existing in the browser.\n\nExample:\n\n```javascript\nApp.Router.map(function() {\n  this.resource('posts', function() {\n    this.route('new');\n  });\n});\n\nApp.Router.reopen({\n  location: 'hash'\n});\n```\n\nThis will result in a posts.new url of `/#/posts/new`.\n\n### HistoryLocation\n\nUsing `HistoryLocation` results in URLs that are indistinguishable from a\nstandard URL. This relies upon the browser's `history` API.\n\nExample:\n\n```javascript\nApp.Router.map(function() {\n  this.resource('posts', function() {\n    this.route('new');\n  });\n});\n\nApp.Router.reopen({\n  location: 'history'\n});\n```\n\nThis will result in a posts.new url of `/posts/new`.\n\nKeep in mind that your server must serve the Ember app at all the routes you\ndefine.\n\n### AutoLocation\n\nUsing `AutoLocation`, the router will use the best Location class supported by\nthe browser it is running in.\n\nBrowsers that support the `history` API will use `HistoryLocation`, those that\ndo not, but still support the `hashchange` event will use `HashLocation`, and\nin the rare case neither is supported will use `NoneLocation`.\n\nExample:\n\n```javascript\nApp.Router.map(function() {\n  this.resource('posts', function() {\n    this.route('new');\n  });\n});\n\nApp.Router.reopen({\n  location: 'auto'\n});\n```\n\nThis will result in a posts.new url of `/posts/new` for modern browsers that\nsupport the `history` api or `/#/posts/new` for older ones, like Internet\nExplorer 9 and below.\n\nWhen a user visits a link to your application, they will be automatically\nupgraded or downgraded to the appropriate `Location` class, with the URL\ntransformed accordingly, if needed.\n\nKeep in mind that since some of your users will use `HistoryLocation`, your\nserver must serve the Ember app at all the routes you define.\n\n### NoneLocation\n\nUsing `NoneLocation` causes Ember to not store the applications URL state\nin the actual URL. This is generally used for testing purposes, and is one\nof the changes made when calling `App.setupForTesting()`.\n\n## Location API\n\nEach location implementation must provide the following methods:\n\n* implementation: returns the string name used to reference the implementation.\n* getURL: returns the current URL.\n* setURL(path): sets the current URL.\n* replaceURL(path): replace the current URL (optional).\n* onUpdateURL(callback): triggers the callback when the URL changes.\n* formatURL(url): formats `url` to be placed into `href` attribute.\n\nCalling setURL or replaceURL will not trigger onUpdateURL callbacks.","static":1},"Ember.AutoLocation":{"name":"Ember.AutoLocation","shortname":"Ember.AutoLocation","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-routing","namespace":"Ember","file":"packages/ember-routing/lib/location/auto_location.js","line":14,"description":"Ember.AutoLocation will select the best location option based off browser\nsupport with the priority order: history, hash, none.\n\nClean pushState paths accessed by hashchange-only browsers will be redirected\nto the hash-equivalent and vice versa so future transitions are consistent.\n\nKeep in mind that since some of your users will use `HistoryLocation`, your\nserver must serve the Ember app at all the routes you define.","static":1},"Ember.HashLocation":{"name":"Ember.HashLocation","shortname":"Ember.HashLocation","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-routing","namespace":"Ember","file":"packages/ember-routing/lib/location/hash_location.js","line":15,"description":"`Ember.HashLocation` implements the location API using the browser's\nhash. At present, it relies on a `hashchange` event existing in the\nbrowser.","extends":"Ember.Object"},"Ember.HistoryLocation":{"name":"Ember.HistoryLocation","shortname":"Ember.HistoryLocation","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-routing","namespace":"Ember","file":"packages/ember-routing/lib/location/history_location.js","line":17,"description":"Ember.HistoryLocation implements the location API using the browser's\nhistory.pushState API.","extends":"Ember.Object"},"Ember.NoneLocation":{"name":"Ember.NoneLocation","shortname":"Ember.NoneLocation","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-routing","namespace":"Ember","file":"packages/ember-routing/lib/location/none_location.js","line":10,"description":"Ember.NoneLocation does not interact with the browser. It is useful for\ntesting, or when you need to manage state with your Router, but temporarily\ndon't want it to muck with the URL (for example when you embed your\napplication in a larger page).","extends":"Ember.Object"},"Ember.Route":{"name":"Ember.Route","shortname":"Ember.Route","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-routing","namespace":"Ember","file":"packages/ember-routing/lib/system/route.js","line":36,"description":"The `Ember.Route` class is used to define individual routes. Refer to\nthe [routing guide](http://emberjs.com/guides/routing/) for documentation.","extends":"Ember.Object","uses":["Ember.ActionHandler"]},"Ember.Router":{"name":"Ember.Router","shortname":"Ember.Router","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-routing","namespace":"Ember","file":"packages/ember-routing/lib/system/router.js","line":34,"description":"The `Ember.Router` class manages the application state and URLs. Refer to\nthe [routing guide](http://emberjs.com/guides/routing/) for documentation.","extends":"Ember.Object"},"Ember.ReduceComputedProperty":{"name":"Ember.ReduceComputedProperty","shortname":"Ember.ReduceComputedProperty","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","namespace":"Ember","file":"packages/ember-runtime/lib/computed/reduce_computed.js","line":462,"description":"A computed property whose dependent keys are arrays and which is updated with\n\"one at a time\" semantics.","extends":"Ember.ComputedProperty","is_constructor":1},"Ember.ArrayController":{"name":"Ember.ArrayController","shortname":"Ember.ArrayController","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/controllers/array_controller.js","line":19,"description":"`Ember.ArrayController` provides a way for you to publish a collection of\nobjects so that you can easily bind to the collection from a Handlebars\n`#each` helper, an `Ember.CollectionView`, or other controllers.\n\nThe advantage of using an `ArrayController` is that you only have to set up\nyour view bindings once; to change what's displayed, simply swap out the\n`model` property on the controller.\n\nFor example, imagine you wanted to display a list of items fetched via an XHR\nrequest. Create an `Ember.ArrayController` and set its `model` property:\n\n```javascript\nMyApp.listController = Ember.ArrayController.create();\n\n$.get('people.json', function(data) {\n  MyApp.listController.set('model', data);\n});\n```\n\nThen, create a view that binds to your new controller:\n\n```handlebars\n{{#each person in MyApp.listController}}\n  {{person.firstName}} {{person.lastName}}\n{{/each}}\n```\n\nAlthough you are binding to the controller, the behavior of this controller\nis to pass through any methods or properties to the underlying array. This\ncapability comes from `Ember.ArrayProxy`, which this class inherits from.\n\nSometimes you want to display computed properties within the body of an\n`#each` helper that depend on the underlying items in `model`, but are not\npresent on those items.   To do this, set `itemController` to the name of a\ncontroller (probably an `ObjectController`) that will wrap each individual item.\n\nFor example:\n\n```handlebars\n{{#each post in controller}}\n  <li>{{post.title}} ({{post.titleLength}} characters)</li>\n{{/each}}\n```\n\n```javascript\nApp.PostsController = Ember.ArrayController.extend({\n  itemController: 'post'\n});\n\nApp.PostController = Ember.ObjectController.extend({\n  // the `title` property will be proxied to the underlying post.\n  titleLength: function() {\n    return this.get('title').length;\n  }.property('title')\n});\n```\n\nIn some cases it is helpful to return a different `itemController` depending\non the particular item.  Subclasses can do this by overriding\n`lookupItemController`.\n\nFor example:\n\n```javascript\nApp.MyArrayController = Ember.ArrayController.extend({\n  lookupItemController: function( object ) {\n    if (object.get('isSpecial')) {\n      return \"special\"; // use App.SpecialController\n    } else {\n      return \"regular\"; // use App.RegularController\n    }\n  }\n});\n```\n\nThe itemController instances will have a `parentController` property set to\nthe `ArrayController` instance.","extends":"Ember.ArrayProxy","uses":["Ember.SortableMixin","Ember.ControllerMixin"]},"Ember.Controller":{"name":"Ember.Controller","shortname":"Ember.Controller","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/controllers/controller.js","line":11,"extends":"Ember.Object","uses":["Ember.ControllerMixin"]},"Ember.ObjectController":{"name":"Ember.ObjectController","shortname":"Ember.ObjectController","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/controllers/object_controller.js","line":9,"description":"`Ember.ObjectController` is part of Ember's Controller layer. It is intended\nto wrap a single object, proxying unhandled attempts to `get` and `set` to the underlying\nmodel object, and to forward unhandled action attempts to its `target`.\n\n`Ember.ObjectController` derives this functionality from its superclass\n`Ember.ObjectProxy` and the `Ember.ControllerMixin` mixin.","extends":"Ember.ObjectProxy","uses":["Ember.ControllerMixin"]},"Function":{"name":"Function","shortname":"Function","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-runtime","namespace":""},"Ember.ProxyMixin":{"name":"Ember.ProxyMixin","shortname":"Ember.ProxyMixin","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/mixins/-proxy.js","line":37,"description":"`Ember.ProxyMixin` forwards all properties not defined by the proxy itself\nto a proxied `content` object.  See Ember.ObjectProxy for more details."},"Ember.ActionHandler":{"name":"Ember.ActionHandler","shortname":"Ember.ActionHandler","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":["Ember.ControllerMixin","Ember.Route","Ember.CoreView"],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/mixins/action_handler.js","line":10,"description":"The `Ember.ActionHandler` mixin implements support for moving an `actions`\nproperty to an `_actions` property at extend time, and adding `_actions`\nto the object's mergedProperties list.\n\n`Ember.ActionHandler` is available on some familiar classes including\n`Ember.Route`, `Ember.View`, `Ember.Component`, and controllers such as\n`Ember.Controller` and `Ember.ObjectController`.\n(Internally the mixin is used by `Ember.CoreView`, `Ember.ControllerMixin`,\nand `Ember.Route` and available to the above classes through\ninheritance.)"},"Ember.Array":{"name":"Ember.Array","shortname":"Ember.Array","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":["Ember.MutableArray"],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/mixins/array.js","line":57,"description":"This mixin implements Observer-friendly Array-like behavior. It is not a\nconcrete implementation, but it can be used up by other classes that want\nto appear like arrays.\n\nFor example, ArrayProxy and ArrayController are both concrete classes that can\nbe instantiated to implement array-like behavior. Both of these classes use\nthe Array Mixin by way of the MutableArray mixin, which allows observable\nchanges to be made to the underlying array.\n\nUnlike `Ember.Enumerable,` this mixin defines methods specifically for\ncollections that provide index-ordered access to their contents. When you\nare designing code that needs to accept any kind of Array-like object, you\nshould use these methods instead of Array primitives because these will\nproperly notify observers of changes to the array.\n\nAlthough these methods are efficient, they do add a layer of indirection to\nyour application so it is a good idea to use them only when you need the\nflexibility of using both true JavaScript arrays and \"virtual\" arrays such\nas controllers and collections.\n\nYou can use the methods defined in this module to access and modify array\ncontents in a KVO-friendly way. You can also be notified whenever the\nmembership of an array changes by using `.observes('myArray.[]')`.\n\nTo support `Ember.Array` in your own class, you must override two\nprimitives to use it: `replace()` and `objectAt()`.\n\nNote that the Ember.Array mixin also incorporates the `Ember.Enumerable`\nmixin. All `Ember.Array`-like objects are also enumerable.","uses":["Ember.Enumerable"],"since":"Ember 0.9.0"},"Ember.Comparable":{"name":"Ember.Comparable","shortname":"Ember.Comparable","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/mixins/comparable.js","line":11,"description":"Implements some standard methods for comparing objects. Add this mixin to\nany class you create that can compare its instances.\n\nYou should implement the `compare()` method.","since":"Ember 0.9"},"Ember.ControllerContentModelAliasDeprecation":{"name":"Ember.ControllerContentModelAliasDeprecation","shortname":"Ember.ControllerContentModelAliasDeprecation","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","namespace":"Ember","file":"packages/ember-runtime/lib/mixins/controller_content_model_alias_deprecation.js","line":4,"description":"The ControllerContentModelAliasDeprecation mixin is used to provide a useful\ndeprecation warning when specifying `content` directly on a `Ember.Controller`\n(without also specifying `model`).\n\nEmber versions prior to 1.7 used `model` as an alias of `content`, but due to\nmuch confusion this alias was reversed (so `content` is now an alias of `model).\n\nThis change reduces many caveats with model/content, and also sets a\nsimple ground rule: Never set a controllers content, rather always set\nit's model and ember will do the right thing.\n\n\n`Ember.ControllerContentModelAliasDeprecation` is used internally by Ember in\n`Ember.Controller`.","access":"private","tagname":"","since":"1.7.0"},"Ember.Copyable":{"name":"Ember.Copyable","shortname":"Ember.Copyable","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":["Ember.NativeArray","Ember.Set"],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/mixins/copyable.js","line":15,"description":"Implements some standard methods for copying an object. Add this mixin to\nany object you create that can create a copy of itself. This mixin is\nadded automatically to the built-in array.\n\nYou should generally implement the `copy()` method to return a copy of the\nreceiver.\n\nNote that `frozenCopy()` will only work if you also implement\n`Ember.Freezable`.","since":"Ember 0.9"},"Ember.Deferred":{"name":"Ember.Deferred","shortname":"Ember.Deferred","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/mixins/deferred.js","line":13},"Ember.Enumerable":{"name":"Ember.Enumerable","shortname":"Ember.Enumerable","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":["Ember.Array","Ember.MutableEnumerable"],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/mixins/enumerable.js","line":57,"description":"This mixin defines the common interface implemented by enumerable objects\nin Ember. Most of these methods follow the standard Array iteration\nAPI defined up to JavaScript 1.8 (excluding language-specific features that\ncannot be emulated in older versions of JavaScript).\n\nThis mixin is applied automatically to the Array class on page load, so you\ncan use any of these methods on simple arrays. If Array already implements\none of these methods, the mixin will not override them.\n\n## Writing Your Own Enumerable\n\nTo make your own custom class enumerable, you need two items:\n\n1. You must have a length property. This property should change whenever\n   the number of items in your enumerable object changes. If you use this\n   with an `Ember.Object` subclass, you should be sure to change the length\n   property using `set().`\n\n2. You must implement `nextObject().` See documentation.\n\nOnce you have these two methods implemented, apply the `Ember.Enumerable` mixin\nto your class and you will be able to enumerate the contents of your object\nlike any other collection.\n\n## Using Ember Enumeration with Other Libraries\n\nMany other libraries provide some kind of iterator or enumeration like\nfacility. This is often where the most common API conflicts occur.\nEmber's API is designed to be as friendly as possible with other\nlibraries by implementing only methods that mostly correspond to the\nJavaScript 1.8 API.","since":"Ember 0.9"},"Ember.Evented":{"name":"Ember.Evented","shortname":"Ember.Evented","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":["Ember.CoreView"],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/mixins/evented.js","line":14,"description":"This mixin allows for Ember objects to subscribe to and emit events.\n\n```javascript\nApp.Person = Ember.Object.extend(Ember.Evented, {\n  greet: function() {\n    // ...\n    this.trigger('greet');\n  }\n});\n\nvar person = App.Person.create();\n\nperson.on('greet', function() {\n  console.log('Our person has greeted');\n});\n\nperson.greet();\n\n// outputs: 'Our person has greeted'\n```\n\nYou can also chain multiple event subscriptions:\n\n```javascript\nperson.on('greet', function() {\n  console.log('Our person has greeted');\n}).one('greet', function() {\n  console.log('Offer one-time special');\n}).off('event', this, forgetThis);\n```"},"Ember.Freezable":{"name":"Ember.Freezable","shortname":"Ember.Freezable","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":["Ember.Set"],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/mixins/freezable.js","line":10,"description":"The `Ember.Freezable` mixin implements some basic methods for marking an\nobject as frozen. Once an object is frozen it should be read only. No changes\nmay be made the internal state of the object.\n\n## Enforcement\n\nTo fully support freezing in your subclass, you must include this mixin and\noverride any method that might alter any property on the object to instead\nraise an exception. You can check the state of an object by checking the\n`isFrozen` property.\n\nAlthough future versions of JavaScript may support language-level freezing\nobject objects, that is not the case today. Even if an object is freezable,\nit is still technically possible to modify the object, even though it could\nbreak other parts of your application that do not expect a frozen object to\nchange. It is, therefore, very important that you always respect the\n`isFrozen` property on all freezable objects.\n\n## Example Usage\n\nThe example below shows a simple object that implement the `Ember.Freezable`\nprotocol.\n\n```javascript\nContact = Ember.Object.extend(Ember.Freezable, {\n  firstName: null,\n  lastName: null,\n\n  // swaps the names\n  swapNames: function() {\n    if (this.get('isFrozen')) throw Ember.FROZEN_ERROR;\n    var tmp = this.get('firstName');\n    this.set('firstName', this.get('lastName'));\n    this.set('lastName', tmp);\n    return this;\n  }\n\n});\n\nc = Contact.create({ firstName: \"John\", lastName: \"Doe\" });\nc.swapNames();  // returns c\nc.freeze();\nc.swapNames();  // EXCEPTION\n```\n\n## Copying\n\nUsually the `Ember.Freezable` protocol is implemented in cooperation with the\n`Ember.Copyable` protocol, which defines a `frozenCopy()` method that will\nreturn a frozen object, if the object implements this method as well.","since":"Ember 0.9"},"Ember.MutableArray":{"name":"Ember.MutableArray","shortname":"Ember.MutableArray","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":["Ember.ArrayProxy","Ember.NativeArray"],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/mixins/mutable_array.js","line":31,"description":"This mixin defines the API for modifying array-like objects. These methods\ncan be applied only to a collection that keeps its items in an ordered set.\nIt builds upon the Array mixin and adds methods to modify the array.\nConcrete implementations of this class include ArrayProxy and ArrayController.\n\nIt is important to use the methods in this class to modify arrays so that\nchanges are observable. This allows the binding system in Ember to function\ncorrectly.\n\n\nNote that an Array can change even if it does not implement this mixin.\nFor example, one might implement a SparseArray that cannot be directly\nmodified, but if its underlying enumerable changes, it will change also.","uses":["Ember.Array","Ember.MutableEnumerable"]},"Ember.MutableEnumerable":{"name":"Ember.MutableEnumerable","shortname":"Ember.MutableEnumerable","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":["Ember.MutableArray","Ember.SortableMixin","Ember.Set"],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/mixins/mutable_enumerable.js","line":11,"description":"This mixin defines the API for modifying generic enumerables. These methods\ncan be applied to an object regardless of whether it is ordered or\nunordered.\n\nNote that an Enumerable can change even if it does not implement this mixin.\nFor example, a MappedEnumerable cannot be directly modified but if its\nunderlying enumerable changes, it will change also.\n\n## Adding Objects\n\nTo add an object to an enumerable, use the `addObject()` method. This\nmethod will only add the object to the enumerable if the object is not\nalready present and is of a type supported by the enumerable.\n\n```javascript\nset.addObject(contact);\n```\n\n## Removing Objects\n\nTo remove an object from an enumerable, use the `removeObject()` method. This\nwill only remove the object if it is present in the enumerable, otherwise\nthis method has no effect.\n\n```javascript\nset.removeObject(contact);\n```\n\n## Implementing In Your Own Code\n\nIf you are implementing an object and want to support this API, just include\nthis mixin in your class and implement the required methods. In your unit\ntests, be sure to apply the Ember.MutableEnumerableTests to your object.","uses":["Ember.Enumerable"]},"Ember.Observable":{"name":"Ember.Observable","shortname":"Ember.Observable","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":["Ember.NativeArray","Ember.Object"],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/mixins/observable.js","line":34,"description":"## Overview\n\nThis mixin provides properties and property observing functionality, core\nfeatures of the Ember object model.\n\nProperties and observers allow one object to observe changes to a\nproperty on another object. This is one of the fundamental ways that\nmodels, controllers and views communicate with each other in an Ember\napplication.\n\nAny object that has this mixin applied can be used in observer\noperations. That includes `Ember.Object` and most objects you will\ninteract with as you write your Ember application.\n\nNote that you will not generally apply this mixin to classes yourself,\nbut you will use the features provided by this module frequently, so it\nis important to understand how to use it.\n\n## Using `get()` and `set()`\n\nBecause of Ember's support for bindings and observers, you will always\naccess properties using the get method, and set properties using the\nset method. This allows the observing objects to be notified and\ncomputed properties to be handled properly.\n\nMore documentation about `get` and `set` are below.\n\n## Observing Property Changes\n\nYou typically observe property changes simply by adding the `observes`\ncall to the end of your method declarations in classes that you write.\nFor example:\n\n```javascript\nEmber.Object.extend({\n  valueObserver: function() {\n    // Executes whenever the \"value\" property changes\n  }.observes('value')\n});\n```\n\nAlthough this is the most common way to add an observer, this capability\nis actually built into the `Ember.Object` class on top of two methods\ndefined in this mixin: `addObserver` and `removeObserver`. You can use\nthese two methods to add and remove observers yourself if you need to\ndo so at runtime.\n\nTo add an observer for a property, call:\n\n```javascript\nobject.addObserver('propertyKey', targetObject, targetAction)\n```\n\nThis will call the `targetAction` method on the `targetObject` whenever\nthe value of the `propertyKey` changes.\n\nNote that if `propertyKey` is a computed property, the observer will be\ncalled when any of the property dependencies are changed, even if the\nresulting value of the computed property is unchanged. This is necessary\nbecause computed properties are not computed until `get` is called."},"Ember.PromiseProxyMixin":{"name":"Ember.PromiseProxyMixin","shortname":"Ember.PromiseProxyMixin","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-runtime","namespace":"","file":"packages/ember-runtime/lib/mixins/promise_proxy.js","line":36,"description":"A low level mixin making ObjectProxy, ObjectController or ArrayController's promise aware.\n\n```javascript\nvar ObjectPromiseController = Ember.ObjectController.extend(Ember.PromiseProxyMixin);\n\nvar controller = ObjectPromiseController.create({\n  promise: $.getJSON('/some/remote/data.json')\n});\n\ncontroller.then(function(json){\n   // the json\n}, function(reason) {\n   // the reason why you have no json\n});\n```\n\nthe controller has bindable attributes which\ntrack the promises life cycle\n\n```javascript\ncontroller.get('isPending')   //=> true\ncontroller.get('isSettled')  //=> false\ncontroller.get('isRejected')  //=> false\ncontroller.get('isFulfilled') //=> false\n```\n\nWhen the the $.getJSON completes, and the promise is fulfilled\nwith json, the life cycle attributes will update accordingly.\n\n```javascript\ncontroller.get('isPending')   //=> false\ncontroller.get('isSettled')   //=> true\ncontroller.get('isRejected')  //=> false\ncontroller.get('isFulfilled') //=> true\n```\n\nAs the controller is an ObjectController, and the json now its content,\nall the json properties will be available directly from the controller.\n\n```javascript\n// Assuming the following json:\n{\n  firstName: 'Stefan',\n  lastName: 'Penner'\n}\n\n// both properties will accessible on the controller\ncontroller.get('firstName') //=> 'Stefan'\ncontroller.get('lastName')  //=> 'Penner'\n```\n\nIf the controller is backing a template, the attributes are\nbindable from within that template\n\n```handlebars\n{{#if isPending}}\n  loading...\n{{else}}\n  firstName: {{firstName}}\n  lastName: {{lastName}}\n{{/if}}\n```"},"Ember.SortableMixin":{"name":"Ember.SortableMixin","shortname":"Ember.SortableMixin","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":["Ember.ArrayController"],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/mixins/sortable.js","line":23,"description":"`Ember.SortableMixin` provides a standard interface for array proxies\nto specify a sort order and maintain this sorting when objects are added,\nremoved, or updated without changing the implicit order of their underlying\nmodel array:\n\n```javascript\nsongs = [\n  {trackNumber: 4, title: 'Ob-La-Di, Ob-La-Da'},\n  {trackNumber: 2, title: 'Back in the U.S.S.R.'},\n  {trackNumber: 3, title: 'Glass Onion'},\n];\n\nsongsController = Ember.ArrayController.create({\n  model: songs,\n  sortProperties: ['trackNumber'],\n  sortAscending: true\n});\n\nsongsController.get('firstObject');  // {trackNumber: 2, title: 'Back in the U.S.S.R.'}\n\nsongsController.addObject({trackNumber: 1, title: 'Dear Prudence'});\nsongsController.get('firstObject');  // {trackNumber: 1, title: 'Dear Prudence'}\n```\n\nIf you add or remove the properties to sort by or change the sort direction the model\nsort order will be automatically updated.\n\n```javascript\nsongsController.set('sortProperties', ['title']);\nsongsController.get('firstObject'); // {trackNumber: 2, title: 'Back in the U.S.S.R.'}\n\nsongsController.toggleProperty('sortAscending');\nsongsController.get('firstObject'); // {trackNumber: 4, title: 'Ob-La-Di, Ob-La-Da'}\n```\n\n`SortableMixin` works by sorting the `arrangedContent` array, which is the array that\n`ArrayProxy` displays. Due to the fact that the underlying 'content' array is not changed, that\narray will not display the sorted list:\n\n ```javascript\nsongsController.get('content').get('firstObject'); // Returns the unsorted original content\nsongsController.get('firstObject'); // Returns the sorted content.\n```\n\nAlthough the sorted content can also be accessed through the `arrangedContent` property,\nit is preferable to use the proxied class and not the `arrangedContent` array directly.","uses":["Ember.MutableEnumerable"]},"Ember.TargetActionSupport":{"name":"Ember.TargetActionSupport","shortname":"Ember.TargetActionSupport","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":["Ember.TextSupport"],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/mixins/target_action_support.js","line":12,"description":"`Ember.TargetActionSupport` is a mixin that can be included in a class\nto add a `triggerAction` method with semantics similar to the Handlebars\n`{{action}}` helper. In normal Ember usage, the `{{action}}` helper is\nusually the best choice. This mixin is most often useful when you are\ndoing more complex event handling in View objects.\n\nSee also `Ember.ViewTargetActionSupport`, which has\nview-aware defaults for target and actionContext.","extends":"Ember.Mixin"},"Ember.ArrayProxy":{"name":"Ember.ArrayProxy","shortname":"Ember.ArrayProxy","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/system/array_proxy.js","line":32,"description":"An ArrayProxy wraps any other object that implements `Ember.Array` and/or\n`Ember.MutableArray,` forwarding all requests. This makes it very useful for\na number of binding use cases or other cases where being able to swap\nout the underlying array is useful.\n\nA simple example of usage:\n\n```javascript\nvar pets = ['dog', 'cat', 'fish'];\nvar ap = Ember.ArrayProxy.create({ content: Ember.A(pets) });\n\nap.get('firstObject');                        // 'dog'\nap.set('content', ['amoeba', 'paramecium']);\nap.get('firstObject');                        // 'amoeba'\n```\n\nThis class can also be useful as a layer to transform the contents of\nan array, as they are accessed. This can be done by overriding\n`objectAtContent`:\n\n```javascript\nvar pets = ['dog', 'cat', 'fish'];\nvar ap = Ember.ArrayProxy.create({\n    content: Ember.A(pets),\n    objectAtContent: function(idx) {\n        return this.get('content').objectAt(idx).toUpperCase();\n    }\n});\n\nap.get('firstObject'); // . 'DOG'\n```","extends":"Ember.Object","uses":["Ember.MutableArray"]},"Ember.CoreObject":{"name":"Ember.CoreObject","shortname":"Ember.CoreObject","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/system/core_object.js","line":212},"Ember.EachProxy":{"name":"Ember.EachProxy","shortname":"Ember.EachProxy","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/system/each_proxy.js","line":94,"description":"This is the object instance returned when you get the `@each` property on an\narray. It uses the unknownProperty handler to automatically create\nEachArray instances for property names.","access":"private","tagname":"","extends":"Ember.Object"},"Ember.Namespace":{"name":"Ember.Namespace","shortname":"Ember.Namespace","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/system/namespace.js","line":18,"description":"A Namespace is an object usually used to contain other objects or methods\nsuch as an application or framework. Create a namespace anytime you want\nto define one of these new containers.\n\n# Example Usage\n\n```javascript\nMyFramework = Ember.Namespace.create({\n  VERSION: '1.0.0'\n});\n```","extends":"Ember.Object"},"Ember.NativeArray":{"name":"Ember.NativeArray","shortname":"Ember.NativeArray","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/system/native_array.js","line":26,"description":"The NativeArray mixin contains the properties needed to to make the native\nArray support Ember.MutableArray and all of its dependent APIs. Unless you\nhave `Ember.EXTEND_PROTOTYPES` or `Ember.EXTEND_PROTOTYPES.Array` set to\nfalse, this will be applied automatically. Otherwise you can apply the mixin\nat anytime by calling `Ember.NativeArray.activate`.","uses":["Ember.MutableArray","Ember.Observable","Ember.Copyable"]},"Ember.Object":{"name":"Ember.Object","shortname":"Ember.Object","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/system/object.js","line":11,"description":"`Ember.Object` is the main base class for all Ember objects. It is a subclass\nof `Ember.CoreObject` with the `Ember.Observable` mixin applied. For details,\nsee the documentation for each of these.","extends":"Ember.CoreObject","uses":["Ember.Observable"]},"Ember.ObjectProxy":{"name":"Ember.ObjectProxy","shortname":"Ember.ObjectProxy","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","namespace":"Ember","file":"packages/ember-runtime/lib/system/object_proxy.js","line":4,"description":"`Ember.ObjectProxy` forwards all properties not defined by the proxy itself\nto a proxied `content` object.\n\n```javascript\nobject = Ember.Object.create({\n  name: 'Foo'\n});\n\nproxy = Ember.ObjectProxy.create({\n  content: object\n});\n\n// Access and change existing properties\nproxy.get('name')          // 'Foo'\nproxy.set('name', 'Bar');\nobject.get('name')         // 'Bar'\n\n// Create new 'description' property on `object`\nproxy.set('description', 'Foo is a whizboo baz');\nobject.get('description')  // 'Foo is a whizboo baz'\n```\n\nWhile `content` is unset, setting a property to be delegated will throw an\nError.\n\n```javascript\nproxy = Ember.ObjectProxy.create({\n  content: null,\n  flag: null\n});\nproxy.set('flag', true);\nproxy.get('flag');         // true\nproxy.get('foo');          // undefined\nproxy.set('foo', 'data');  // throws Error\n```\n\nDelegated properties can be bound to and will change when content is updated.\n\nComputed properties on the proxy itself can depend on delegated properties.\n\n```javascript\nProxyWithComputedProperty = Ember.ObjectProxy.extend({\n  fullName: function () {\n    var firstName = this.get('firstName'),\n        lastName = this.get('lastName');\n    if (firstName && lastName) {\n      return firstName + ' ' + lastName;\n    }\n    return firstName || lastName;\n  }.property('firstName', 'lastName')\n});\n\nproxy = ProxyWithComputedProperty.create();\n\nproxy.get('fullName');  // undefined\nproxy.set('content', {\n  firstName: 'Tom', lastName: 'Dale'\n}); // triggers property change for fullName on proxy\n\nproxy.get('fullName');  // 'Tom Dale'\n```","extends":"Ember._ProxyMixin"},"Ember.Service":{"name":"Ember.Service","shortname":"Ember.Service","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","namespace":"Ember","file":"packages/ember-runtime/lib/system/service.js","line":7,"extends":"Ember.Object"},"Ember.Set":{"name":"Ember.Set","shortname":"Ember.Set","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-runtime","namespace":"Ember","file":"packages/ember-runtime/lib/system/set.js","line":28,"description":"An unordered collection of objects.\n\nA Set works a bit like an array except that its items are not ordered. You\ncan create a set to efficiently test for membership for an object. You can\nalso iterate through a set just like an array, even accessing objects by\nindex, however there is no guarantee as to their order.\n\nAll Sets are observable via the Enumerable Observer API - which works\non any enumerable object including both Sets and Arrays.\n\n## Creating a Set\n\nYou can create a set like you would most objects using\n`new Ember.Set()`. Most new sets you create will be empty, but you can\nalso initialize the set with some content by passing an array or other\nenumerable of objects to the constructor.\n\nFinally, you can pass in an existing set and the set will be copied. You\ncan also create a copy of a set by calling `Ember.Set#copy()`.\n\n```javascript\n// creates a new empty set\nvar foundNames = new Ember.Set();\n\n// creates a set with four names in it.\nvar names = new Ember.Set([\"Charles\", \"Tom\", \"Juan\", \"Alex\"]); // :P\n\n// creates a copy of the names set.\nvar namesCopy = new Ember.Set(names);\n\n// same as above.\nvar anotherNamesCopy = names.copy();\n```\n\n## Adding/Removing Objects\n\nYou generally add or remove objects from a set using `add()` or\n`remove()`. You can add any type of object including primitives such as\nnumbers, strings, and booleans.\n\nUnlike arrays, objects can only exist one time in a set. If you call `add()`\non a set with the same object multiple times, the object will only be added\nonce. Likewise, calling `remove()` with the same object multiple times will\nremove the object the first time and have no effect on future calls until\nyou add the object to the set again.\n\nNOTE: You cannot add/remove `null` or `undefined` to a set. Any attempt to do\nso will be ignored.\n\nIn addition to add/remove you can also call `push()`/`pop()`. Push behaves\njust like `add()` but `pop()`, unlike `remove()` will pick an arbitrary\nobject, remove it and return it. This is a good way to use a set as a job\nqueue when you don't care which order the jobs are executed in.\n\n## Testing for an Object\n\nTo test for an object's presence in a set you simply call\n`Ember.Set#contains()`.\n\n## Observing changes\n\nWhen using `Ember.Set`, you can observe the `\"[]\"` property to be\nalerted whenever the content changes. You can also add an enumerable\nobserver to the set to be notified of specific objects that are added and\nremoved from the set. See [Ember.Enumerable](/api/classes/Ember.Enumerable.html)\nfor more information on enumerables.\n\nThis is often unhelpful. If you are filtering sets of objects, for instance,\nit is very inefficient to re-filter all of the items each time the set\nchanges. It would be better if you could just adjust the filtered set based\non what was changed on the original set. The same issue applies to merging\nsets, as well.\n\n## Other Methods\n\n`Ember.Set` primary implements other mixin APIs. For a complete reference\non the methods you will use with `Ember.Set`, please consult these mixins.\nThe most useful ones will be `Ember.Enumerable` and\n`Ember.MutableEnumerable` which implement most of the common iterator\nmethods you are used to on Array.\n\nNote that you can also use the `Ember.Copyable` and `Ember.Freezable`\nAPIs on `Ember.Set` as well. Once a set is frozen it can no longer be\nmodified. The benefit of this is that when you call `frozenCopy()` on it,\nEmber will avoid making copies of the set. This allows you to write\ncode that can know with certainty when the underlying set data will or\nwill not be modified.","extends":"Ember.CoreObject","uses":["Ember.MutableEnumerable","Ember.Copyable","Ember.Freezable"],"since":"Ember 0.9","deprecated":true},"Ember.SubArray":{"name":"Ember.SubArray","shortname":"Ember.SubArray","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","namespace":"Ember","file":"packages/ember-runtime/lib/system/subarray.js","line":14,"description":"An `Ember.SubArray` tracks an array in a way similar to, but more specialized\nthan, `Ember.TrackedArray`.  It is useful for keeping track of the indexes of\nitems within a filtered array."},"Ember.TrackedArray":{"name":"Ember.TrackedArray","shortname":"Ember.TrackedArray","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","namespace":"Ember","file":"packages/ember-runtime/lib/system/tracked_array.js","line":10,"description":"An `Ember.TrackedArray` tracks array operations.  It's useful when you want to\nlazily compute the indexes of items in an array after they've been shifted by\nsubsequent operations.","params":[{"name":"items","description":"The array to be tracked.  This is used just to get\nthe initial items for the starting state of retain:n.","type":"Array","optional":true,"optdefault":"["}]},"Ember.inject":{"name":"Ember.inject","shortname":"Ember.inject","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","namespace":"Ember","file":"packages/ember-runtime/lib/inject.js","line":6,"description":"Namespace for injection helper methods."},"Ember.Test.Adapter":{"name":"Ember.Test.Adapter","shortname":"Ember.Test.Adapter","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-testing","namespace":"Ember.Test","file":"packages/ember-testing/lib/adapters/adapter.js","line":9,"description":"The primary purpose of this class is to create hooks that can be implemented\nby an adapter for various test frameworks."},"Ember.Test.QUnitAdapter":{"name":"Ember.Test.QUnitAdapter","shortname":"Ember.Test.QUnitAdapter","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","namespace":"Ember.Test","file":"packages/ember-testing/lib/adapters/qunit.js","line":4,"description":"This class implements the methods defined by Ember.Test.Adapter for the\nQUnit testing framework.","extends":"Ember.Test.Adapter"},"Ember.Test":{"name":"Ember.Test","shortname":"Ember.Test","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-testing","namespace":"Ember","file":"packages/ember-testing/lib/test.js","line":17,"description":"This is a container for an assortment of testing related functionality:\n\n* Choose your default test adapter (for your framework of choice).\n* Register/Unregister additional test helpers.\n* Setup callbacks to be fired when the test helpers are injected into\n  your application."},"Ember.ComponentTemplateDeprecation":{"name":"Ember.ComponentTemplateDeprecation","shortname":"Ember.ComponentTemplateDeprecation","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","namespace":"Ember","file":"packages/ember-views/lib/mixins/component_template_deprecation.js","line":5,"description":"The ComponentTemplateDeprecation mixin is used to provide a useful\ndeprecation warning when using either `template` or `templateName` with\na component. The `template` and `templateName` properties specified at\nextend time are moved to `layout` and `layoutName` respectively.\n\n`Ember.ComponentTemplateDeprecation` is used internally by Ember in\n`Ember.Component`."},"Ember.ViewTargetActionSupport":{"name":"Ember.ViewTargetActionSupport","shortname":"Ember.ViewTargetActionSupport","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","namespace":"Ember","file":"packages/ember-views/lib/mixins/view_target_action_support.js","line":5,"description":"`Ember.ViewTargetActionSupport` is a mixin that can be included in a\nview class to add a `triggerAction` method with semantics similar to\nthe Handlebars `{{action}}` helper. It provides intelligent defaults\nfor the action's target: the view's controller; and the context that is\nsent with the action: the view's context.\n\nNote: In normal Ember usage, the `{{action}}` helper is usually the best\nchoice. This mixin is most often useful when you are doing more complex\nevent handling in custom View subclasses.\n\nFor example:\n\n```javascript\nApp.SaveButtonView = Ember.View.extend(Ember.ViewTargetActionSupport, {\n  action: 'save',\n  click: function() {\n    this.triggerAction(); // Sends the `save` action, along with the current context\n                          // to the current controller\n  }\n});\n```\n\nThe `action` can be provided as properties of an optional object argument\nto `triggerAction` as well.\n\n```javascript\nApp.SaveButtonView = Ember.View.extend(Ember.ViewTargetActionSupport, {\n  click: function() {\n    this.triggerAction({\n      action: 'save'\n    }); // Sends the `save` action, along with the current context\n        // to the current controller\n  }\n});\n```","extends":"Ember.TargetActionSupport"},"Ember.EventDispatcher":{"name":"Ember.EventDispatcher","shortname":"Ember.EventDispatcher","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-views","namespace":"Ember","file":"packages/ember-views/lib/system/event_dispatcher.js","line":22,"description":"`Ember.EventDispatcher` handles delegating browser events to their\ncorresponding `Ember.Views.` For example, when you click on a view,\n`Ember.EventDispatcher` ensures that that view's `mouseDown` method gets\ncalled.","access":"private","tagname":"","extends":"Ember.Object"},"Ember.CollectionView":{"name":"Ember.CollectionView","shortname":"Ember.CollectionView","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-views","namespace":"Ember","file":"packages/ember-views/lib/views/collection_view.js","line":22,"description":"`Ember.CollectionView` is an `Ember.View` descendent responsible for managing\na collection (an array or array-like object) by maintaining a child view object\nand associated DOM representation for each item in the array and ensuring\nthat child views and their associated rendered HTML are updated when items in\nthe array are added, removed, or replaced.\n\n## Setting content\n\nThe managed collection of objects is referenced as the `Ember.CollectionView`\ninstance's `content` property.\n\n```javascript\nsomeItemsView = Ember.CollectionView.create({\n  content: ['A', 'B','C']\n})\n```\n\nThe view for each item in the collection will have its `content` property set\nto the item.\n\n## Specifying `itemViewClass`\n\nBy default the view class for each item in the managed collection will be an\ninstance of `Ember.View`. You can supply a different class by setting the\n`CollectionView`'s `itemViewClass` property.\n\nGiven the following application code:\n\n```javascript\nvar App = Ember.Application.create();\nApp.ItemListView = Ember.CollectionView.extend({\n  classNames: ['a-collection'],\n  content: ['A','B','C'],\n  itemViewClass: Ember.View.extend({\n    template: Ember.Handlebars.compile(\"the letter: {{view.content}}\")\n  })\n});\n```\n\nAnd a simple application template:\n\n```handlebars\n{{view 'item-list'}}\n```\n\nThe following HTML will result:\n\n```html\n<div class=\"ember-view a-collection\">\n  <div class=\"ember-view\">the letter: A</div>\n  <div class=\"ember-view\">the letter: B</div>\n  <div class=\"ember-view\">the letter: C</div>\n</div>\n```\n\n## Automatic matching of parent/child tagNames\n\nSetting the `tagName` property of a `CollectionView` to any of\n\"ul\", \"ol\", \"table\", \"thead\", \"tbody\", \"tfoot\", \"tr\", or \"select\" will result\nin the item views receiving an appropriately matched `tagName` property.\n\nGiven the following application code:\n\n```javascript\nvar App = Ember.Application.create();\nApp.UnorderedListView = Ember.CollectionView.create({\n  tagName: 'ul',\n  content: ['A','B','C'],\n  itemViewClass: Ember.View.extend({\n    template: Ember.Handlebars.compile(\"the letter: {{view.content}}\")\n  })\n});\n```\n\nAnd a simple application template:\n\n```handlebars\n{{view 'unordered-list-view'}}\n```\n\nThe following HTML will result:\n\n```html\n<ul class=\"ember-view a-collection\">\n  <li class=\"ember-view\">the letter: A</li>\n  <li class=\"ember-view\">the letter: B</li>\n  <li class=\"ember-view\">the letter: C</li>\n</ul>\n```\n\nAdditional `tagName` pairs can be provided by adding to\n`Ember.CollectionView.CONTAINER_MAP`. For example:\n\n```javascript\nEmber.CollectionView.CONTAINER_MAP['article'] = 'section'\n```\n\n## Programmatic creation of child views\n\nFor cases where additional customization beyond the use of a single\n`itemViewClass` or `tagName` matching is required CollectionView's\n`createChildView` method can be overidden:\n\n```javascript\nApp.CustomCollectionView = Ember.CollectionView.extend({\n  createChildView: function(viewClass, attrs) {\n    if (attrs.content.kind == 'album') {\n      viewClass = App.AlbumView;\n    } else {\n      viewClass = App.SongView;\n    }\n    return this._super(viewClass, attrs);\n  }\n});\n```\n\n## Empty View\n\nYou can provide an `Ember.View` subclass to the `Ember.CollectionView`\ninstance as its `emptyView` property. If the `content` property of a\n`CollectionView` is set to `null` or an empty array, an instance of this view\nwill be the `CollectionView`s only child.\n\n```javascript\nvar App = Ember.Application.create();\nApp.ListWithNothing = Ember.CollectionView.create({\n  classNames: ['nothing'],\n  content: null,\n  emptyView: Ember.View.extend({\n    template: Ember.Handlebars.compile(\"The collection is empty\")\n  })\n});\n```\n\nAnd a simple application template:\n\n```handlebars\n{{view 'list-with-nothing'}}\n```\n\nThe following HTML will result:\n\n```html\n<div class=\"ember-view nothing\">\n  <div class=\"ember-view\">\n    The collection is empty\n  </div>\n</div>\n```\n\n## Adding and Removing items\n\nThe `childViews` property of a `CollectionView` should not be directly\nmanipulated. Instead, add, remove, replace items from its `content` property.\nThis will trigger appropriate changes to its rendered HTML.","extends":"Ember.ContainerView","since":"Ember 0.9"},"Ember.Component":{"name":"Ember.Component","shortname":"Ember.Component","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-views","namespace":"Ember","file":"packages/ember-views/lib/views/component.js","line":20,"description":"An `Ember.Component` is a view that is completely\nisolated. Property access in its templates go\nto the view object and actions are targeted at\nthe view object. There is no access to the\nsurrounding context or outer controller; all\ncontextual information must be passed in.\n\nThe easiest way to create an `Ember.Component` is via\na template. If you name a template\n`components/my-foo`, you will be able to use\n`{{my-foo}}` in other templates, which will make\nan instance of the isolated component.\n\n```handlebars\n{{app-profile person=currentUser}}\n```\n\n```handlebars\n<!-- app-profile template -->\n<h1>{{person.title}}</h1>\n<img {{bind-attr src=person.avatar}}>\n<p class='signature'>{{person.signature}}</p>\n```\n\nYou can use `yield` inside a template to\ninclude the **contents** of any block attached to\nthe component. The block will be executed in the\ncontext of the surrounding context or outer controller:\n\n```handlebars\n{{#app-profile person=currentUser}}\n  <p>Admin mode</p>\n  {{! Executed in the controller's context. }}\n{{/app-profile}}\n```\n\n```handlebars\n<!-- app-profile template -->\n<h1>{{person.title}}</h1>\n{{! Executed in the components context. }}\n{{yield}} {{! block contents }}\n```\n\nIf you want to customize the component, in order to\nhandle events or actions, you implement a subclass\nof `Ember.Component` named after the name of the\ncomponent. Note that `Component` needs to be appended to the name of\nyour subclass like `AppProfileComponent`.\n\nFor example, you could implement the action\n`hello` for the `app-profile` component:\n\n```javascript\nApp.AppProfileComponent = Ember.Component.extend({\n  actions: {\n    hello: function(name) {\n      console.log(\"Hello\", name);\n    }\n  }\n});\n```\n\nAnd then use it in the component's template:\n\n```handlebars\n<!-- app-profile template -->\n\n<h1>{{person.title}}</h1>\n{{yield}} <!-- block contents -->\n\n<button {{action 'hello' person.name}}>\n  Say Hello to {{person.name}}\n</button>\n```\n\nComponents must have a `-` in their name to avoid\nconflicts with built-in controls that wrap HTML\nelements. This is consistent with the same\nrequirement in web components.","extends":"Ember.View"},"Ember.ContainerView":{"name":"Ember.ContainerView","shortname":"Ember.ContainerView","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-views","namespace":"Ember","file":"packages/ember-views/lib/views/container_view.js","line":35,"description":"A `ContainerView` is an `Ember.View` subclass that implements `Ember.MutableArray`\nallowing programmatic management of its child views.\n\n## Setting Initial Child Views\n\nThe initial array of child views can be set in one of two ways. You can\nprovide a `childViews` property at creation time that contains instance of\n`Ember.View`:\n\n```javascript\naContainer = Ember.ContainerView.create({\n  childViews: [Ember.View.create(), Ember.View.create()]\n});\n```\n\nYou can also provide a list of property names whose values are instances of\n`Ember.View`:\n\n```javascript\naContainer = Ember.ContainerView.create({\n  childViews: ['aView', 'bView', 'cView'],\n  aView: Ember.View.create(),\n  bView: Ember.View.create(),\n  cView: Ember.View.create()\n});\n```\n\nThe two strategies can be combined:\n\n```javascript\naContainer = Ember.ContainerView.create({\n  childViews: ['aView', Ember.View.create()],\n  aView: Ember.View.create()\n});\n```\n\nEach child view's rendering will be inserted into the container's rendered\nHTML in the same order as its position in the `childViews` property.\n\n## Adding and Removing Child Views\n\nThe container view implements `Ember.MutableArray` allowing programmatic management of its child views.\n\nTo remove a view, pass that view into a `removeObject` call on the container view.\n\nGiven an empty `<body>` the following code\n\n```javascript\naContainer = Ember.ContainerView.create({\n  classNames: ['the-container'],\n  childViews: ['aView', 'bView'],\n  aView: Ember.View.create({\n    template: Ember.Handlebars.compile(\"A\")\n  }),\n  bView: Ember.View.create({\n    template: Ember.Handlebars.compile(\"B\")\n  })\n});\n\naContainer.appendTo('body');\n```\n\nResults in the HTML\n\n```html\n<div class=\"ember-view the-container\">\n  <div class=\"ember-view\">A</div>\n  <div class=\"ember-view\">B</div>\n</div>\n```\n\nRemoving a view\n\n```javascript\naContainer.toArray();  // [aContainer.aView, aContainer.bView]\naContainer.removeObject(aContainer.get('bView'));\naContainer.toArray();  // [aContainer.aView]\n```\n\nWill result in the following HTML\n\n```html\n<div class=\"ember-view the-container\">\n  <div class=\"ember-view\">A</div>\n</div>\n```\n\nSimilarly, adding a child view is accomplished by adding `Ember.View` instances to the\ncontainer view.\n\nGiven an empty `<body>` the following code\n\n```javascript\naContainer = Ember.ContainerView.create({\n  classNames: ['the-container'],\n  childViews: ['aView', 'bView'],\n  aView: Ember.View.create({\n    template: Ember.Handlebars.compile(\"A\")\n  }),\n  bView: Ember.View.create({\n    template: Ember.Handlebars.compile(\"B\")\n  })\n});\n\naContainer.appendTo('body');\n```\n\nResults in the HTML\n\n```html\n<div class=\"ember-view the-container\">\n  <div class=\"ember-view\">A</div>\n  <div class=\"ember-view\">B</div>\n</div>\n```\n\nAdding a view\n\n```javascript\nAnotherViewClass = Ember.View.extend({\n  template: Ember.Handlebars.compile(\"Another view\")\n});\n\naContainer.toArray();  // [aContainer.aView, aContainer.bView]\naContainer.pushObject(AnotherViewClass.create());\naContainer.toArray(); // [aContainer.aView, aContainer.bView, <AnotherViewClass instance>]\n```\n\nWill result in the following HTML\n\n```html\n<div class=\"ember-view the-container\">\n  <div class=\"ember-view\">A</div>\n  <div class=\"ember-view\">B</div>\n  <div class=\"ember-view\">Another view</div>\n</div>\n```\n\n## Templates and Layout\n\nA `template`, `templateName`, `defaultTemplate`, `layout`, `layoutName` or\n`defaultLayout` property on a container view will not result in the template\nor layout being rendered. The HTML contents of a `Ember.ContainerView`'s DOM\nrepresentation will only be the rendered HTML of its child views.","extends":"Ember.View"},"Ember.CoreView":{"name":"Ember.CoreView","shortname":"Ember.CoreView","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","namespace":"Ember","file":"packages/ember-views/lib/views/core_view.js","line":15,"description":"`Ember.CoreView` is an abstract class that exists to give view-like behavior\nto both Ember's main view class `Ember.View` and other classes like\n`Ember._SimpleMetamorphView` that don't need the fully functionaltiy of\n`Ember.View`.\n\nUnless you have specific needs for `CoreView`, you will use `Ember.View`\nin your applications.","extends":"Ember.Object","uses":["Ember.Evented","Ember.ActionHandler"]},"Ember.View":{"name":"Ember.View","shortname":"Ember.View","classitems":[],"plugins":[],"extensions":[],"plugin_for":[],"extension_for":[],"module":"ember","submodule":"ember-views","namespace":"Ember","file":"packages/ember-views/lib/views/view.js","line":97,"description":"`Ember.View` is the class in Ember responsible for encapsulating templates of\nHTML content, combining templates with data to render as sections of a page's\nDOM, and registering and responding to user-initiated events.\n\n## HTML Tag\n\nThe default HTML tag name used for a view's DOM representation is `div`. This\ncan be customized by setting the `tagName` property. The following view\nclass:\n\n```javascript\nParagraphView = Ember.View.extend({\n  tagName: 'em'\n});\n```\n\nWould result in instances with the following HTML:\n\n```html\n<em id=\"ember1\" class=\"ember-view\"></em>\n```\n\n## HTML `class` Attribute\n\nThe HTML `class` attribute of a view's tag can be set by providing a\n`classNames` property that is set to an array of strings:\n\n```javascript\nMyView = Ember.View.extend({\n  classNames: ['my-class', 'my-other-class']\n});\n```\n\nWill result in view instances with an HTML representation of:\n\n```html\n<div id=\"ember1\" class=\"ember-view my-class my-other-class\"></div>\n```\n\n`class` attribute values can also be set by providing a `classNameBindings`\nproperty set to an array of properties names for the view. The return value\nof these properties will be added as part of the value for the view's `class`\nattribute. These properties can be computed properties:\n\n```javascript\nMyView = Ember.View.extend({\n  classNameBindings: ['propertyA', 'propertyB'],\n  propertyA: 'from-a',\n  propertyB: function() {\n    if (someLogic) { return 'from-b'; }\n  }.property()\n});\n```\n\nWill result in view instances with an HTML representation of:\n\n```html\n<div id=\"ember1\" class=\"ember-view from-a from-b\"></div>\n```\n\nIf the value of a class name binding returns a boolean the property name\nitself will be used as the class name if the property is true. The class name\nwill not be added if the value is `false` or `undefined`.\n\n```javascript\nMyView = Ember.View.extend({\n  classNameBindings: ['hovered'],\n  hovered: true\n});\n```\n\nWill result in view instances with an HTML representation of:\n\n```html\n<div id=\"ember1\" class=\"ember-view hovered\"></div>\n```\n\nWhen using boolean class name bindings you can supply a string value other\nthan the property name for use as the `class` HTML attribute by appending the\npreferred value after a \":\" character when defining the binding:\n\n```javascript\nMyView = Ember.View.extend({\n  classNameBindings: ['awesome:so-very-cool'],\n  awesome: true\n});\n```\n\nWill result in view instances with an HTML representation of:\n\n```html\n<div id=\"ember1\" class=\"ember-view so-very-cool\"></div>\n```\n\nBoolean value class name bindings whose property names are in a\ncamelCase-style format will be converted to a dasherized format:\n\n```javascript\nMyView = Ember.View.extend({\n  classNameBindings: ['isUrgent'],\n  isUrgent: true\n});\n```\n\nWill result in view instances with an HTML representation of:\n\n```html\n<div id=\"ember1\" class=\"ember-view is-urgent\"></div>\n```\n\nClass name bindings can also refer to object values that are found by\ntraversing a path relative to the view itself:\n\n```javascript\nMyView = Ember.View.extend({\n  classNameBindings: ['messages.empty']\n  messages: Ember.Object.create({\n    empty: true\n  })\n});\n```\n\nWill result in view instances with an HTML representation of:\n\n```html\n<div id=\"ember1\" class=\"ember-view empty\"></div>\n```\n\nIf you want to add a class name for a property which evaluates to true and\nand a different class name if it evaluates to false, you can pass a binding\nlike this:\n\n```javascript\n// Applies 'enabled' class when isEnabled is true and 'disabled' when isEnabled is false\nEmber.View.extend({\n  classNameBindings: ['isEnabled:enabled:disabled']\n  isEnabled: true\n});\n```\n\nWill result in view instances with an HTML representation of:\n\n```html\n<div id=\"ember1\" class=\"ember-view enabled\"></div>\n```\n\nWhen isEnabled is `false`, the resulting HTML reprensentation looks like\nthis:\n\n```html\n<div id=\"ember1\" class=\"ember-view disabled\"></div>\n```\n\nThis syntax offers the convenience to add a class if a property is `false`:\n\n```javascript\n// Applies no class when isEnabled is true and class 'disabled' when isEnabled is false\nEmber.View.extend({\n  classNameBindings: ['isEnabled::disabled']\n  isEnabled: true\n});\n```\n\nWill result in view instances with an HTML representation of:\n\n```html\n<div id=\"ember1\" class=\"ember-view\"></div>\n```\n\nWhen the `isEnabled` property on the view is set to `false`, it will result\nin view instances with an HTML representation of:\n\n```html\n<div id=\"ember1\" class=\"ember-view disabled\"></div>\n```\n\nUpdates to the the value of a class name binding will result in automatic\nupdate of the  HTML `class` attribute in the view's rendered HTML\nrepresentation. If the value becomes `false` or `undefined` the class name\nwill be removed.\n\nBoth `classNames` and `classNameBindings` are concatenated properties. See\n[Ember.Object](/api/classes/Ember.Object.html) documentation for more\ninformation about concatenated properties.\n\n## HTML Attributes\n\nThe HTML attribute section of a view's tag can be set by providing an\n`attributeBindings` property set to an array of property names on the view.\nThe return value of these properties will be used as the value of the view's\nHTML associated attribute:\n\n```javascript\nAnchorView = Ember.View.extend({\n  tagName: 'a',\n  attributeBindings: ['href'],\n  href: 'http://google.com'\n});\n```\n\nWill result in view instances with an HTML representation of:\n\n```html\n<a id=\"ember1\" class=\"ember-view\" href=\"http://google.com\"></a>\n```\n\nOne property can be mapped on to another by placing a \":\" between\nthe source property and the destination property:\n\n```javascript\nAnchorView = Ember.View.extend({\n  tagName: 'a',\n  attributeBindings: ['url:href'],\n  url: 'http://google.com'\n});\n```\n\nWill result in view instances with an HTML representation of:\n\n```html\n<a id=\"ember1\" class=\"ember-view\" href=\"http://google.com\"></a>\n```\n\nIf the return value of an `attributeBindings` monitored property is a boolean\nthe property will follow HTML's pattern of repeating the attribute's name as\nits value:\n\n```javascript\nMyTextInput = Ember.View.extend({\n  tagName: 'input',\n  attributeBindings: ['disabled'],\n  disabled: true\n});\n```\n\nWill result in view instances with an HTML representation of:\n\n```html\n<input id=\"ember1\" class=\"ember-view\" disabled=\"disabled\" />\n```\n\n`attributeBindings` can refer to computed properties:\n\n```javascript\nMyTextInput = Ember.View.extend({\n  tagName: 'input',\n  attributeBindings: ['disabled'],\n  disabled: function() {\n    if (someLogic) {\n      return true;\n    } else {\n      return false;\n    }\n  }.property()\n});\n```\n\nUpdates to the the property of an attribute binding will result in automatic\nupdate of the  HTML attribute in the view's rendered HTML representation.\n\n`attributeBindings` is a concatenated property. See [Ember.Object](/api/classes/Ember.Object.html)\ndocumentation for more information about concatenated properties.\n\n## Templates\n\nThe HTML contents of a view's rendered representation are determined by its\ntemplate. Templates can be any function that accepts an optional context\nparameter and returns a string of HTML that will be inserted within the\nview's tag. Most typically in Ember this function will be a compiled\n`Ember.Handlebars` template.\n\n```javascript\nAView = Ember.View.extend({\n  template: Ember.Handlebars.compile('I am the template')\n});\n```\n\nWill result in view instances with an HTML representation of:\n\n```html\n<div id=\"ember1\" class=\"ember-view\">I am the template</div>\n```\n\nWithin an Ember application is more common to define a Handlebars templates as\npart of a page:\n\n```html\n<script type='text/x-handlebars' data-template-name='some-template'>\n  Hello\n</script>\n```\n\nAnd associate it by name using a view's `templateName` property:\n\n```javascript\nAView = Ember.View.extend({\n  templateName: 'some-template'\n});\n```\n\nIf you have nested resources, your Handlebars template will look like this:\n\n```html\n<script type='text/x-handlebars' data-template-name='posts/new'>\n  <h1>New Post</h1>\n</script>\n```\n\nAnd `templateName` property:\n\n```javascript\nAView = Ember.View.extend({\n  templateName: 'posts/new'\n});\n```\n\nUsing a value for `templateName` that does not have a Handlebars template\nwith a matching `data-template-name` attribute will throw an error.\n\nFor views classes that may have a template later defined (e.g. as the block\nportion of a `{{view}}` Handlebars helper call in another template or in\na subclass), you can provide a `defaultTemplate` property set to compiled\ntemplate function. If a template is not later provided for the view instance\nthe `defaultTemplate` value will be used:\n\n```javascript\nAView = Ember.View.extend({\n  defaultTemplate: Ember.Handlebars.compile('I was the default'),\n  template: null,\n  templateName: null\n});\n```\n\nWill result in instances with an HTML representation of:\n\n```html\n<div id=\"ember1\" class=\"ember-view\">I was the default</div>\n```\n\nIf a `template` or `templateName` is provided it will take precedence over\n`defaultTemplate`:\n\n```javascript\nAView = Ember.View.extend({\n  defaultTemplate: Ember.Handlebars.compile('I was the default')\n});\n\naView = AView.create({\n  template: Ember.Handlebars.compile('I was the template, not default')\n});\n```\n\nWill result in the following HTML representation when rendered:\n\n```html\n<div id=\"ember1\" class=\"ember-view\">I was the template, not default</div>\n```\n\n## View Context\n\nThe default context of the compiled template is the view's controller:\n\n```javascript\nAView = Ember.View.extend({\n  template: Ember.Handlebars.compile('Hello {{excitedGreeting}}')\n});\n\naController = Ember.Object.create({\n  firstName: 'Barry',\n  excitedGreeting: function() {\n    return this.get(\"content.firstName\") + \"!!!\"\n  }.property()\n});\n\naView = AView.create({\n  controller: aController\n});\n```\n\nWill result in an HTML representation of:\n\n```html\n<div id=\"ember1\" class=\"ember-view\">Hello Barry!!!</div>\n```\n\nA context can also be explicitly supplied through the view's `context`\nproperty. If the view has neither `context` nor `controller` properties, the\n`parentView`'s context will be used.\n\n## Layouts\n\nViews can have a secondary template that wraps their main template. Like\nprimary templates, layouts can be any function that  accepts an optional\ncontext parameter and returns a string of HTML that will be inserted inside\nview's tag. Views whose HTML element is self closing (e.g. `<input />`)\ncannot have a layout and this property will be ignored.\n\nMost typically in Ember a layout will be a compiled `Ember.Handlebars`\ntemplate.\n\nA view's layout can be set directly with the `layout` property or reference\nan existing Handlebars template by name with the `layoutName` property.\n\nA template used as a layout must contain a single use of the Handlebars\n`{{yield}}` helper. The HTML contents of a view's rendered `template` will be\ninserted at this location:\n\n```javascript\nAViewWithLayout = Ember.View.extend({\n  layout: Ember.Handlebars.compile(\"<div class='my-decorative-class'>{{yield}}</div>\"),\n  template: Ember.Handlebars.compile(\"I got wrapped\")\n});\n```\n\nWill result in view instances with an HTML representation of:\n\n```html\n<div id=\"ember1\" class=\"ember-view\">\n  <div class=\"my-decorative-class\">\n    I got wrapped\n  </div>\n</div>\n```\n\nSee [Ember.Handlebars.helpers.yield](/api/classes/Ember.Handlebars.helpers.html#method_yield)\nfor more information.\n\n## Responding to Browser Events\n\nViews can respond to user-initiated events in one of three ways: method\nimplementation, through an event manager, and through `{{action}}` helper use\nin their template or layout.\n\n### Method Implementation\n\nViews can respond to user-initiated events by implementing a method that\nmatches the event name. A `jQuery.Event` object will be passed as the\nargument to this method.\n\n```javascript\nAView = Ember.View.extend({\n  click: function(event) {\n    // will be called when when an instance's\n    // rendered element is clicked\n  }\n});\n```\n\n### Event Managers\n\nViews can define an object as their `eventManager` property. This object can\nthen implement methods that match the desired event names. Matching events\nthat occur on the view's rendered HTML or the rendered HTML of any of its DOM\ndescendants will trigger this method. A `jQuery.Event` object will be passed\nas the first argument to the method and an  `Ember.View` object as the\nsecond. The `Ember.View` will be the view whose rendered HTML was interacted\nwith. This may be the view with the `eventManager` property or one of its\ndescendent views.\n\n```javascript\nAView = Ember.View.extend({\n  eventManager: Ember.Object.create({\n    doubleClick: function(event, view) {\n      // will be called when when an instance's\n      // rendered element or any rendering\n      // of this views's descendent\n      // elements is clicked\n    }\n  })\n});\n```\n\nAn event defined for an event manager takes precedence over events of the\nsame name handled through methods on the view.\n\n```javascript\nAView = Ember.View.extend({\n  mouseEnter: function(event) {\n    // will never trigger.\n  },\n  eventManager: Ember.Object.create({\n    mouseEnter: function(event, view) {\n      // takes precedence over AView#mouseEnter\n    }\n  })\n});\n```\n\nSimilarly a view's event manager will take precedence for events of any views\nrendered as a descendent. A method name that matches an event name will not\nbe called if the view instance was rendered inside the HTML representation of\na view that has an `eventManager` property defined that handles events of the\nname. Events not handled by the event manager will still trigger method calls\non the descendent.\n\n```javascript\nvar App = Ember.Application.create();\nApp.OuterView = Ember.View.extend({\n  template: Ember.Handlebars.compile(\"outer {{#view 'inner'}}inner{{/view}} outer\"),\n  eventManager: Ember.Object.create({\n    mouseEnter: function(event, view) {\n      // view might be instance of either\n      // OuterView or InnerView depending on\n      // where on the page the user interaction occured\n    }\n  })\n});\n\nApp.InnerView = Ember.View.extend({\n  click: function(event) {\n    // will be called if rendered inside\n    // an OuterView because OuterView's\n    // eventManager doesn't handle click events\n  },\n  mouseEnter: function(event) {\n    // will never be called if rendered inside\n    // an OuterView.\n  }\n});\n```\n\n### Handlebars `{{action}}` Helper\n\nSee [Handlebars.helpers.action](/api/classes/Ember.Handlebars.helpers.html#method_action).\n\n### Event Names\n\nAll of the event handling approaches described above respond to the same set\nof events. The names of the built-in events are listed below. (The hash of\nbuilt-in events exists in `Ember.EventDispatcher`.) Additional, custom events\ncan be registered by using `Ember.Application.customEvents`.\n\nTouch events:\n\n* `touchStart`\n* `touchMove`\n* `touchEnd`\n* `touchCancel`\n\nKeyboard events\n\n* `keyDown`\n* `keyUp`\n* `keyPress`\n\nMouse events\n\n* `mouseDown`\n* `mouseUp`\n* `contextMenu`\n* `click`\n* `doubleClick`\n* `mouseMove`\n* `focusIn`\n* `focusOut`\n* `mouseEnter`\n* `mouseLeave`\n\nForm events:\n\n* `submit`\n* `change`\n* `focusIn`\n* `focusOut`\n* `input`\n\nHTML5 drag and drop events:\n\n* `dragStart`\n* `drag`\n* `dragEnter`\n* `dragLeave`\n* `dragOver`\n* `dragEnd`\n* `drop`\n\n## Handlebars `{{view}}` Helper\n\nOther `Ember.View` instances can be included as part of a view's template by\nusing the `{{view}}` Handlebars helper. See [Ember.Handlebars.helpers.view](/api/classes/Ember.Handlebars.helpers.html#method_view)\nfor additional information.","extends":"Ember.CoreView"}}